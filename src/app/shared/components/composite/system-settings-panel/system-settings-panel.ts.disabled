import { Component, computed, inject, signal } from '@angular/core';
import { CommonModule } from '@angular/common';
import { FormControl, FormGroup, ReactiveFormsModule, Validators } from '@angular/forms';
import {
  HardDrive,
  Database,
  Trash2,
  FolderOpen,
  Shield,
  Archive,
  Clock,
  AlertCircle,
  CheckCircle,
  Settings,
  WifiOff,
  Wifi
} from 'lucide-angular';

import {
  RagButton,
  RagIcon,
  RagSelect,
  RagCheckbox
} from '../../../atomic';
import {
  RagCard,
  RagFormField
} from '../../../semantic';
import { SettingsStore, SystemSettings, SecuritySettings } from '../../../../store/settings.store';

interface SystemSettingsForm {
  storageQuotaGb: FormControl<number>;
  cacheSizeMb: FormControl<number>;
  cacheTtlSeconds: FormControl<number>;
  logLevel: FormControl<string>;
  logRetentionDays: FormControl<number>;
  autoBackup: FormControl<boolean>;
  backupIntervalHours: FormControl<number>;
  maxBackups: FormControl<number>;
  dataDirectory: FormControl<string>;
}

interface SecuritySettingsForm {
  airGappedMode: FormControl<boolean>;
  encryptData: FormControl<boolean>;
  logRedaction: FormControl<boolean>;
  auditLogging: FormControl<boolean>;
}

@Component({
  selector: 'rag-system-settings-panel',
  standalone: true,
  imports: [
    CommonModule,
    ReactiveFormsModule,
    RagButton,
    RagIcon,
    RagSelect,
    RagCheckbox,
    RagCard,
    RagFormField
  ],
  template: `
    <div class="system-settings-panel">
      <!-- Storage Management -->
      <rag-card variant="elevated" class="storage-card">
        <div class="section-header">
          <div class="section-info">
            <rag-icon [img]="HardDriveIcon" size="md" />
            <div class="section-text">
              <h3>Storage Management</h3>
              <p class="section-description">
                Configure storage quotas, data directory, and cleanup settings
              </p>
            </div>
          </div>
          <div class="section-status">
            <span class="status-indicator" [class]="storageStatus().variant">
              <rag-icon [img]="storageStatus().icon" size="sm" />
              {{ storageStatus().text }}
            </span>
          </div>
        </div>

        <!-- Storage Overview -->
        @if (systemSettings()) {
          <div class="storage-overview">
            <div class="storage-metrics">
              <div class="metric">
                <rag-icon [img]="DatabaseIcon" size="sm" />
                <span class="metric-label">Storage Quota</span>
                <span class="metric-value">{{ systemSettings()!.storage_quota_gb }} GB</span>
              </div>
              <div class="metric">
                <rag-icon [img]="FolderOpenIcon" size="sm" />
                <span class="metric-label">Data Directory</span>
                <span class="metric-value">{{ systemSettings()!.data_directory }}</span>
              </div>
              <div class="metric">
                <rag-icon [img]="ArchiveIcon" size="sm" />
                <span class="metric-label">Auto Backup</span>
                <span class="metric-value">
                  @if (systemSettings()!.auto_backup) {
                    Every {{ systemSettings()!.backup_interval_hours }}h
                  } @else {
                    Disabled
                  }
                </span>
              </div>
            </div>
          </div>
        }

        @if (settingsStore.error()) {
          <rag-alert variant="error" [icon]="'alert-circle'">
            {{ settingsStore.error() }}
          </rag-alert>
        }

        <form [formGroup]="systemForm" (ngSubmit)="saveSystemSettings()" class="storage-form">
          <!-- Storage Quota -->
          <rag-form-field
            label="Storage Quota"
            description="Maximum storage space for knowledge bases and cache">
            <rag-slider
              formControlName="storageQuotaGb"
              [min]="1"
              [max]="50"
              [step]="1"
              [disabled]="settingsStore.isLoading()"
              [showValue]="true"
              [valueSuffix]="' GB'"
              [showTicks]="false">
            </rag-slider>
          </rag-form-field>

          <!-- Data Directory -->
          <rag-form-field
            label="Data Directory"
            description="Location where knowledge bases and application data are stored">
            <div class="directory-input">
              <input
                type="text"
                formControlName="dataDirectory"
                [disabled]="settingsStore.isLoading()"
                readonly
                class="form-input directory-path" />
              <rag-button
                type="button"
                variant="outline"
                size="sm"
                [disabled]="settingsStore.isLoading()"
                (click)="selectDataDirectory()">
                <rag-icon [img]="FolderOpenIcon" size="sm" />
                Browse
              </rag-button>
            </div>
          </rag-form-field>

          <!-- Auto Backup -->
          <rag-form-field
            label="Automatic Backup"
            description="Automatically create backups of knowledge bases and settings">
            <rag-toggle
              formControlName="autoBackup"
              [disabled]="settingsStore.isLoading()">
              Enable automatic backups
            </rag-toggle>
          </rag-form-field>

          @if (systemForm.value.autoBackup) {
            <!-- Backup Interval -->
            <rag-form-field
              label="Backup Interval"
              description="How often to create automatic backups">
              <rag-slider
                formControlName="backupIntervalHours"
                [min]="1"
                [max]="168"
                [step]="1"
                [disabled]="settingsStore.isLoading()"
                [showValue]="true"
                [valueSuffix]="' hours'"
                [showTicks]="false">
              </rag-slider>
            </rag-form-field>

            <!-- Max Backups -->
            <rag-form-field
              label="Maximum Backups"
              description="Number of backup files to keep (older backups are deleted)">
              <rag-slider
                formControlName="maxBackups"
                [min]="1"
                [max]="30"
                [step]="1"
                [disabled]="settingsStore.isLoading()"
                [showValue]="true"
                [showTicks]="false">
              </rag-slider>
            </rag-form-field>
          }
        </form>
      </rag-card>

      <!-- Cache & Performance -->
      <rag-card variant="elevated" class="cache-card">
        <div class="section-header">
          <rag-icon [img]="DatabaseIcon" size="md" />
          <h3>Cache & Performance</h3>
        </div>

        <form [formGroup]="systemForm" class="cache-form">
          <!-- Cache Size -->
          <rag-form-field
            label="Cache Size"
            description="Memory allocated for caching search results and embeddings">
            <rag-slider
              formControlName="cacheSizeMb"
              [min]="64"
              [max]="2048"
              [step]="64"
              [disabled]="settingsStore.isLoading()"
              [showValue]="true"
              [valueSuffix]="' MB'"
              [showTicks]="false">
            </rag-slider>
          </rag-form-field>

          <!-- Cache TTL -->
          <rag-form-field
            label="Cache TTL"
            description="How long to keep cached items before expiration">
            <rag-slider
              formControlName="cacheTtlSeconds"
              [min]="300"
              [max]="86400"
              [step]="300"
              [disabled]="settingsStore.isLoading()"
              [showValue]="true"
              [valueFormatter]="formatCacheTtl"
              [showTicks]="false">
            </rag-slider>
          </rag-form-field>

          <!-- Clear Cache Button -->
          <rag-form-field
            label="Cache Management"
            description="Clear cached data to free up memory and force fresh results">
            <rag-button
              type="button"
              variant="outline"
              color="orange"
              [loading]="settingsStore.isLoading()"
              (click)="clearCache()">
              <rag-icon [img]="Trash2Icon" size="sm" />
              Clear All Cache
            </rag-button>
          </rag-form-field>
        </form>
      </rag-card>

      <!-- Security Settings -->
      <rag-card variant="elevated" class="security-card">
        <div class="section-header">
          <div class="section-info">
            <rag-icon [img]="ShieldIcon" size="md" />
            <div class="section-text">
              <h3>Security & Privacy</h3>
              <p class="section-description">
                Configure security policies and data protection settings
              </p>
            </div>
          </div>
          <div class="section-status">
            <span class="status-indicator" [class]="securityStatus().variant">
              <rag-icon [img]="securityStatus().icon" size="sm" />
              {{ securityStatus().text }}
            </span>
          </div>
        </div>

        <form [formGroup]="securityForm" (ngSubmit)="saveSecuritySettings()" class="security-form">
          <!-- Air-gapped Mode -->
          <rag-form-field
            label="Air-gapped Mode"
            description="Block all network connections for maximum security (requires restart)">
            <div class="air-gapped-setting">
              <rag-toggle
                formControlName="airGappedMode"
                [disabled]="settingsStore.isLoading()">
                <div class="toggle-content">
                  <rag-icon [img]="airGappedIcon()" size="sm" />
                  <span>{{ airGappedText() }}</span>
                </div>
              </rag-toggle>
              @if (securityForm.value.airGappedMode) {
                <rag-alert variant="warning" [icon]="'alert-triangle'" size="sm">
                  Application restart required to apply air-gapped mode
                </rag-alert>
              }
            </div>
          </rag-form-field>

          <!-- Data Encryption -->
          <rag-form-field
            label="Data Encryption"
            description="Encrypt stored knowledge bases and cached data">
            <rag-toggle
              formControlName="encryptData"
              [disabled]="settingsStore.isLoading()">
              Encrypt data at rest
            </rag-toggle>
          </rag-form-field>

          <!-- Log Redaction -->
          <rag-form-field
            label="Log Redaction"
            description="Automatically redact sensitive information from log files">
            <rag-toggle
              formControlName="logRedaction"
              [disabled]="settingsStore.isLoading()">
              Enable log redaction
            </rag-toggle>
          </rag-form-field>

          <!-- Audit Logging -->
          <rag-form-field
            label="Audit Logging"
            description="Log security-relevant events for compliance and forensics">
            <rag-toggle
              formControlName="auditLogging"
              [disabled]="settingsStore.isLoading()">
              Enable audit logging
            </rag-toggle>
          </rag-form-field>
        </form>
      </rag-card>

      <!-- Logging Settings -->
      <rag-card variant="elevated" class="logging-card">
        <div class="section-header">
          <rag-icon [img]="SettingsIcon" size="md" />
          <h3>Logging Configuration</h3>
        </div>

        <form [formGroup]="systemForm" class="logging-form">
          <!-- Log Level -->
          <rag-form-field
            label="Log Level"
            description="Minimum severity level for log messages">
            <rag-select
              formControlName="logLevel"
              [disabled]="settingsStore.isLoading()"
              placeholder="Select log level">
              @for (level of logLevels; track level.value) {
                <rag-select-option [value]="level.value">
                  <div class="log-level-option">
                    <span class="level-name">{{ level.label }}</span>
                    <span class="level-description" [class]="level.badge">{{ level.description }}</span>
                  </div>
                </rag-select-option>
              }
            </rag-select>
          </rag-form-field>

          <!-- Log Retention -->
          <rag-form-field
            label="Log Retention"
            description="How long to keep log files before automatic deletion">
            <rag-slider
              formControlName="logRetentionDays"
              [min]="1"
              [max]="365"
              [step]="1"
              [disabled]="settingsStore.isLoading()"
              [showValue]="true"
              [valueSuffix]="' days'"
              [showTicks]="false">
            </rag-slider>
          </rag-form-field>
        </form>
      </rag-card>

      <!-- Actions -->
      <div class="panel-actions">
        <rag-button
          variant="outline"
          (click)="resetAllSettings()"
          [disabled]="settingsStore.isLoading()">
          Reset All to Defaults
        </rag-button>

        <rag-button
          variant="solid"
          [loading]="settingsStore.isLoading()"
          [disabled]="!hasUnsavedChanges()"
          (click)="saveAllSettings()">
          Save All Changes
        </rag-button>
      </div>
    </div>
  `,
  styleUrls: ['./system-settings-panel.scss']
})
export class RagSystemSettingsPanel {
  // Dependencies
  readonly settingsStore = inject(SettingsStore);

  // Icons
  readonly HardDriveIcon = HardDrive;
  readonly DatabaseIcon = Database;
  readonly Trash2Icon = Trash2;
  readonly FolderOpenIcon = FolderOpen;
  readonly ShieldIcon = Shield;
  readonly ArchiveIcon = Archive;
  readonly ClockIcon = Clock;
  readonly AlertCircleIcon = AlertCircle;
  readonly CheckCircleIcon = CheckCircle;
  readonly SettingsIcon = Settings;
  readonly WifiOffIcon = WifiOff;
  readonly WifiIcon = Wifi;

  // Forms
  readonly systemForm = new FormGroup<SystemSettingsForm>({
    storageQuotaGb: new FormControl(5, {
      nonNullable: true,
      validators: [Validators.required, Validators.min(1), Validators.max(50)]
    }),
    cacheSizeMb: new FormControl(256, {
      nonNullable: true,
      validators: [Validators.required, Validators.min(64), Validators.max(2048)]
    }),
    cacheTtlSeconds: new FormControl(3600, {
      nonNullable: true,
      validators: [Validators.required, Validators.min(300), Validators.max(86400)]
    }),
    logLevel: new FormControl('info', {
      nonNullable: true,
      validators: [Validators.required]
    }),
    logRetentionDays: new FormControl(30, {
      nonNullable: true,
      validators: [Validators.required, Validators.min(1), Validators.max(365)]
    }),
    autoBackup: new FormControl(false, { nonNullable: true }),
    backupIntervalHours: new FormControl(24, {
      nonNullable: true,
      validators: [Validators.required, Validators.min(1), Validators.max(168)]
    }),
    maxBackups: new FormControl(7, {
      nonNullable: true,
      validators: [Validators.required, Validators.min(1), Validators.max(30)]
    }),
    dataDirectory: new FormControl('./data', {
      nonNullable: true,
      validators: [Validators.required]
    }),
  });

  readonly securityForm = new FormGroup<SecuritySettingsForm>({
    airGappedMode: new FormControl(false, { nonNullable: true }),
    encryptData: new FormControl(false, { nonNullable: true }),
    logRedaction: new FormControl(true, { nonNullable: true }),
    auditLogging: new FormControl(true, { nonNullable: true }),
  });

  // Configuration options
  readonly logLevels = [
    {
      value: 'trace',
      label: 'Trace',
      description: 'Very detailed',
      badge: 'secondary' as const
    },
    {
      value: 'debug',
      label: 'Debug',
      description: 'Detailed info',
      badge: 'secondary' as const
    },
    {
      value: 'info',
      label: 'Info',
      description: 'General info',
      badge: 'success' as const
    },
    {
      value: 'warn',
      label: 'Warn',
      description: 'Warnings only',
      badge: 'warning' as const
    },
    {
      value: 'error',
      label: 'Error',
      description: 'Errors only',
      badge: 'error' as const
    }
  ];

  // State
  private readonly isInitialized = signal(false);

  // Computed values
  readonly systemSettings = computed(() => this.settingsStore.settings()?.system);
  readonly securitySettings = computed(() => this.settingsStore.settings()?.security);

  readonly storageStatus = computed(() => {
    const settings = this.systemSettings();
    if (!settings) {
      return {
        variant: 'secondary' as const,
        icon: this.AlertCircleIcon,
        text: 'Not Configured'
      };
    }

    if (settings.auto_backup && settings.storage_quota_gb >= 5) {
      return {
        variant: 'success' as const,
        icon: this.CheckCircleIcon,
        text: 'Optimized'
      };
    }

    return {
      variant: 'warning' as const,
      icon: this.HardDriveIcon,
      text: 'Basic Setup'
    };
  });

  readonly securityStatus = computed(() => {
    const settings = this.securitySettings();
    if (!settings) {
      return {
        variant: 'secondary' as const,
        icon: this.AlertCircleIcon,
        text: 'Not Configured'
      };
    }

    const secureFeatures = [
      settings.air_gapped_mode,
      settings.encrypt_data,
      settings.log_redaction,
      settings.audit_logging
    ].filter(Boolean).length;

    if (secureFeatures >= 3) {
      return {
        variant: 'success' as const,
        icon: this.CheckCircleIcon,
        text: 'High Security'
      };
    }

    if (secureFeatures >= 1) {
      return {
        variant: 'warning' as const,
        icon: this.ShieldIcon,
        text: 'Moderate Security'
      };
    }

    return {
      variant: 'error' as const,
      icon: this.AlertCircleIcon,
      text: 'Low Security'
    };
  });

  readonly airGappedIcon = computed(() => {
    return this.securityForm.value.airGappedMode ? this.WifiOffIcon : this.WifiIcon;
  });

  readonly airGappedText = computed(() => {
    return this.securityForm.value.airGappedMode ? 'Air-gapped Mode' : 'Network Enabled';
  });

  constructor() {
    this.initializeStore();
    this.syncFormsWithSettings();
  }

  private async initializeStore() {
    if (!this.settingsStore.isInitialized()) {
      await this.settingsStore.initialize();
    }
    this.isInitialized.set(true);
  }

  private syncFormsWithSettings() {
    const systemSettings = this.systemSettings();
    const securitySettings = this.securitySettings();

    if (systemSettings && this.isInitialized()) {
      this.systemForm.patchValue({
        storageQuotaGb: systemSettings.storage_quota_gb,
        cacheSizeMb: systemSettings.cache_size_mb,
        cacheTtlSeconds: systemSettings.cache_ttl_seconds,
        logLevel: systemSettings.log_level,
        logRetentionDays: systemSettings.log_retention_days,
        autoBackup: systemSettings.auto_backup,
        backupIntervalHours: systemSettings.backup_interval_hours,
        maxBackups: systemSettings.max_backups,
        dataDirectory: systemSettings.data_directory,
      }, { emitEvent: false });
    }

    if (securitySettings && this.isInitialized()) {
      this.securityForm.patchValue({
        airGappedMode: securitySettings.air_gapped_mode,
        encryptData: securitySettings.encrypt_data,
        logRedaction: securitySettings.log_redaction,
        auditLogging: securitySettings.audit_logging,
      }, { emitEvent: false });
    }
  }

  // Actions
  async saveSystemSettings() {
    if (this.systemForm.valid) {
      const formValue = this.systemForm.value;
      const currentSettings = this.settingsStore.settings();

      if (currentSettings) {
        await this.settingsStore.updateSettings({
          system: {
            ...currentSettings.system,
            storage_quota_gb: formValue.storageQuotaGb!,
            cache_size_mb: formValue.cacheSizeMb!,
            cache_ttl_seconds: formValue.cacheTtlSeconds!,
            log_level: formValue.logLevel!,
            log_retention_days: formValue.logRetentionDays!,
            auto_backup: formValue.autoBackup!,
            backup_interval_hours: formValue.backupIntervalHours!,
            max_backups: formValue.maxBackups!,
            data_directory: formValue.dataDirectory!,
          }
        });
      }
    }
  }

  async saveSecuritySettings() {
    if (this.securityForm.valid) {
      const formValue = this.securityForm.value;
      const currentSettings = this.settingsStore.settings();

      if (currentSettings) {
        await this.settingsStore.updateSettings({
          security: {
            ...currentSettings.security,
            air_gapped_mode: formValue.airGappedMode!,
            encrypt_data: formValue.encryptData!,
            log_redaction: formValue.logRedaction!,
            audit_logging: formValue.auditLogging!,
          }
        });
      }
    }
  }

  async saveAllSettings() {
    await Promise.all([
      this.saveSystemSettings(),
      this.saveSecuritySettings()
    ]);
  }

  async selectDataDirectory() {
    try {
      const selectedPath = await this.settingsStore.selectDataDirectory();
      if (selectedPath) {
        this.systemForm.patchValue({ dataDirectory: selectedPath });
      }
    } catch (error) {
      console.error('Failed to select data directory:', error);
    }
  }

  async clearCache() {
    try {
      await this.settingsStore.clearCache();
      // TODO: Show success message
    } catch (error) {
      console.error('Failed to clear cache:', error);
    }
  }

  resetAllSettings() {
    this.systemForm.reset({
      storageQuotaGb: 5,
      cacheSizeMb: 256,
      cacheTtlSeconds: 3600,
      logLevel: 'info',
      logRetentionDays: 30,
      autoBackup: false,
      backupIntervalHours: 24,
      maxBackups: 7,
      dataDirectory: './data',
    });

    this.securityForm.reset({
      airGappedMode: false,
      encryptData: false,
      logRedaction: true,
      auditLogging: true,
    });
  }

  hasUnsavedChanges(): boolean {
    return this.systemForm.dirty || this.securityForm.dirty;
  }

  // Utility methods
  formatCacheTtl = (seconds: number): string => {
    const hours = Math.floor(seconds / 3600);
    const minutes = Math.floor((seconds % 3600) / 60);

    if (hours >= 1) {
      return `${hours}h${minutes > 0 ? ` ${minutes}m` : ''}`;
    }
    return `${minutes}m`;
  };
}
