import { Component, computed, inject, signal } from '@angular/core';
import { CommonModule } from '@angular/common';
import { FormControl, FormGroup, ReactiveFormsModule, Validators } from '@angular/forms';
import {
  Database,
  Search,
  Settings,
  Cpu,
  Target,
  FileText,
  RotateCcw,
  CheckCircle,
  AlertTriangle
} from 'lucide-angular';

import {
  RagButton,
  RagIcon,
  RagSelect,
  RagCheckbox,
  RagInput
} from '../../../atomic';
import {
  RagCard,
  RagFormField
} from '../../../semantic';
import { SettingsStore, KbSettings } from '../../../../store/settings.store';

interface KbConfigurationForm {
  defaultEmbeddingModel: FormControl<string>;
  chunkSize: FormControl<number>;
  chunkOverlap: FormControl<number>;
  searchTopK: FormControl<number>;
  searchThreshold: FormControl<number>;
  enableHybridSearch: FormControl<boolean>;
  enableReranking: FormControl<boolean>;
  citationMode: FormControl<string>;
}

@Component({
  selector: 'rag-kb-configuration-panel',
  standalone: true,
  imports: [
    CommonModule,
    ReactiveFormsModule,
    RagButton,
    RagIcon,
    RagSelect,
    RagCheckbox,
    RagInput,
    RagCard,
    RagFormField
  ],
  template: `
    <div class="kb-configuration-panel">
      <!-- Current Configuration Overview -->
      <rag-card variant="elevated" class="overview-card">
        <div class="overview-header">
          <div class="overview-info">
            <rag-icon [img]="DatabaseIcon" size="md" />
            <div class="overview-text">
              <h3>Knowledge Base Configuration</h3>
              <p class="overview-description">
                Configure embedding models, search parameters, and processing settings
              </p>
            </div>
          </div>
          <div class="overview-status">
            <span class="status-badge" [class]="configurationStatus().variant">
              <rag-icon [img]="configurationStatus().icon" size="sm" />
              {{ configurationStatus().text }}
            </span>
          </div>
        </div>

        <div class="current-config" *ngIf="kbSettings()">
          <div class="config-grid">
            <div class="config-item">
              <rag-icon [img]="CpuIcon" size="sm" />
              <span class="config-label">Embedding Model</span>
              <span class="config-value">{{ getModelDisplayName(kbSettings()!.default_embedding_model) }}</span>
            </div>
            <div class="config-item">
              <rag-icon [img]="FileTextIcon" size="sm" />
              <span class="config-label">Chunk Size</span>
              <span class="config-value">{{ kbSettings()!.chunk_size }} tokens</span>
            </div>
            <div class="config-item">
              <rag-icon [img]="SearchIcon" size="sm" />
              <span class="config-label">Search Top-K</span>
              <span class="config-value">{{ kbSettings()!.search_top_k }} results</span>
            </div>
            <div class="config-item">
              <rag-icon [img]="TargetIcon" size="sm" />
              <span class="config-label">Search Mode</span>
              <span class="config-value">
                @if (kbSettings()!.enable_hybrid_search) {
                  Hybrid (Vector + BM25)
                } @else {
                  Vector Only
                }
              </span>
            </div>
          </div>
        </div>
      </rag-card>

      <!-- Configuration Form -->
      <rag-card variant="elevated" class="config-card">
        <div class="config-header">
          <rag-icon [img]="SettingsIcon" size="md" />
          <h3>Model & Processing Settings</h3>
        </div>

        @if (settingsStore.error()) {
          <div class="error-message">
            Error: {{ settingsStore.error() }}
          </div>
        }

        <form [formGroup]="kbForm" (ngSubmit)="saveConfiguration()" class="config-form">
          <!-- Embedding Model Selection -->
          <rag-form-field
            label="Default Embedding Model"
            description="Model used for generating document embeddings"
            [error]="getFieldError('defaultEmbeddingModel')">
            <select
              formControlName="defaultEmbeddingModel"
              [disabled]="settingsStore.isLoading()"
              class="form-select">
              @for (model of embeddingModels; track model.value) {
                <option [value]="model.value">{{ model.label }} ({{ model.type }})</option>
              }
            </select>
          </rag-form-field>

          <!-- Chunk Size -->
          <rag-form-field
            label="Chunk Size"
            description="Number of tokens per document chunk (affects memory usage and search granularity)">
            <rag-slider
              formControlName="chunkSize"
              [min]="128"
              [max]="2048"
              [step]="64"
              [disabled]="settingsStore.isLoading()"
              [showValue]="true"
              [valueSuffix]="' tokens'"
              [showTicks]="false">
            </rag-slider>
          </rag-form-field>

          <!-- Chunk Overlap -->
          <rag-form-field
            label="Chunk Overlap"
            description="Number of overlapping tokens between chunks (improves context continuity)">
            <rag-slider
              formControlName="chunkOverlap"
              [min]="0"
              [max]="200"
              [step]="10"
              [disabled]="settingsStore.isLoading()"
              [showValue]="true"
              [valueSuffix]="' tokens'"
              [showTicks]="false">
            </rag-slider>
          </rag-form-field>

          <!-- Search Settings -->
          <div class="form-section">
            <h4 class="section-title">
              <rag-icon [img]="SearchIcon" size="sm" />
              Search Configuration
            </h4>

            <!-- Search Top-K -->
            <rag-form-field
              label="Search Top-K"
              description="Maximum number of results to return per search query">
              <rag-slider
                formControlName="searchTopK"
                [min]="1"
                [max]="50"
                [step]="1"
                [disabled]="settingsStore.isLoading()"
                [showValue]="true"
                [valueSuffix]="' results'"
                [showTicks]="false">
              </rag-slider>
            </rag-form-field>

            <!-- Search Threshold -->
            <rag-form-field
              label="Search Threshold"
              description="Minimum similarity score for search results (filters out irrelevant matches)">
              <rag-slider
                formControlName="searchThreshold"
                [min]="0.0"
                [max]="1.0"
                [step]="0.05"
                [disabled]="settingsStore.isLoading()"
                [showValue]="true"
                [valueFormatter]="formatThreshold"
                [showTicks]="false">
              </rag-slider>
            </rag-form-field>

            <!-- Hybrid Search Toggle -->
            <rag-form-field
              label="Enable Hybrid Search"
              description="Combine vector similarity with BM25 lexical search for better results">
              <rag-toggle
                formControlName="enableHybridSearch"
                [disabled]="settingsStore.isLoading()">
                Use hybrid search (Vector + BM25)
              </rag-toggle>
            </rag-form-field>

            <!-- Reranking Toggle -->
            <rag-form-field
              label="Enable Reranking"
              description="Use a cross-encoder model to rerank initial search results">
              <rag-toggle
                formControlName="enableReranking"
                [disabled]="settingsStore.isLoading()">
                Enable result reranking
              </rag-toggle>
            </rag-form-field>
          </div>

          <!-- Citation Settings -->
          <div class="form-section">
            <h4 class="section-title">
              <rag-icon [img]="FileTextIcon" size="sm" />
              Citation Configuration
            </h4>

            <rag-form-field
              label="Citation Policy"
              description="How citations should be handled in search results"
              [error]="getFieldError('citationMode')">
              <rag-select
                formControlName="citationMode"
                [disabled]="settingsStore.isLoading()"
                placeholder="Select citation mode">
                @for (mode of citationModes; track mode.value) {
                  <rag-select-option [value]="mode.value">
                    <div class="citation-option">
                      <span class="citation-name">{{ mode.label }}</span>
                      <span class="citation-description">{{ mode.description }}</span>
                    </div>
                  </rag-select-option>
                }
              </rag-select>
            </rag-form-field>
          </div>

          <!-- Actions -->
          <div class="form-actions">
            <rag-button
              type="button"
              variant="outline"
              (click)="resetConfiguration()"
              [disabled]="settingsStore.isLoading()">
              <rag-icon [img]="RotateCcwIcon" size="sm" />
              Reset to Defaults
            </rag-button>

            <rag-button
              type="button"
              variant="outline"
              (click)="testConfiguration()"
              [disabled]="settingsStore.isLoading() || kbForm.invalid">
              <rag-icon [img]="SearchIcon" size="sm" />
              Test Configuration
            </rag-button>

            <rag-button
              type="submit"
              variant="solid"
              [loading]="settingsStore.isLoading()"
              [disabled]="kbForm.invalid">
              <rag-icon [img]="CheckCircleIcon" size="sm" />
              Save Configuration
            </rag-button>
          </div>
        </form>
      </rag-card>
    </div>
  `,
  styleUrls: ['./kb-configuration-panel.scss']
})
export class RagKbConfigurationPanel {
  // Dependencies
  readonly settingsStore = inject(SettingsStore);

  // Icons
  readonly DatabaseIcon = Database;
  readonly SearchIcon = Search;
  readonly SettingsIcon = Settings;
  readonly CpuIcon = Cpu;
  readonly TargetIcon = Target;
  readonly FileTextIcon = FileText;
  readonly RotateCcwIcon = RotateCcw;
  readonly CheckCircleIcon = CheckCircle;
  readonly AlertTriangleIcon = AlertTriangle;

  // Form
  readonly kbForm = new FormGroup<KbConfigurationForm>({
    defaultEmbeddingModel: new FormControl('sentence-transformers/all-MiniLM-L6-v2', {
      nonNullable: true,
      validators: [Validators.required]
    }),
    chunkSize: new FormControl(512, {
      nonNullable: true,
      validators: [Validators.required, Validators.min(128), Validators.max(2048)]
    }),
    chunkOverlap: new FormControl(50, {
      nonNullable: true,
      validators: [Validators.required, Validators.min(0), Validators.max(200)]
    }),
    searchTopK: new FormControl(10, {
      nonNullable: true,
      validators: [Validators.required, Validators.min(1), Validators.max(50)]
    }),
    searchThreshold: new FormControl(0.7, {
      nonNullable: true,
      validators: [Validators.required, Validators.min(0.0), Validators.max(1.0)]
    }),
    enableHybridSearch: new FormControl(true, { nonNullable: true }),
    enableReranking: new FormControl(true, { nonNullable: true }),
    citationMode: new FormControl('mandatory', {
      nonNullable: true,
      validators: [Validators.required]
    }),
  });

  // Configuration options
  readonly embeddingModels = [
    {
      value: 'sentence-transformers/all-MiniLM-L6-v2',
      label: 'all-MiniLM-L6-v2',
      type: 'Fast',
      badge: 'success' as const
    },
    {
      value: 'sentence-transformers/all-mpnet-base-v2',
      label: 'all-mpnet-base-v2',
      type: 'Quality',
      badge: 'primary' as const
    },
    {
      value: 'sentence-transformers/multi-qa-MiniLM-L6-cos-v1',
      label: 'multi-qa-MiniLM-L6-cos-v1',
      type: 'Q&A',
      badge: 'secondary' as const
    },
    {
      value: 'sentence-transformers/paraphrase-multilingual-MiniLM-L12-v2',
      label: 'paraphrase-multilingual-MiniLM-L12-v2',
      type: 'Multi-lang',
      badge: 'warning' as const
    }
  ];

  readonly citationModes = [
    {
      value: 'mandatory',
      label: 'Mandatory',
      description: 'All results must include citations'
    },
    {
      value: 'optional',
      label: 'Optional',
      description: 'Citations included when available'
    },
    {
      value: 'disabled',
      label: 'Disabled',
      description: 'No citation tracking'
    }
  ];

  // State
  private readonly isInitialized = signal(false);

  // Computed values
  readonly kbSettings = computed(() => this.settingsStore.settings()?.kb);

  readonly configurationStatus = computed(() => {
    const settings = this.kbSettings();
    if (!settings) {
      return {
        variant: 'secondary' as const,
        icon: this.AlertTriangleIcon,
        text: 'Not Configured'
      };
    }

    if (settings.enable_hybrid_search && settings.enable_reranking) {
      return {
        variant: 'success' as const,
        icon: this.CheckCircleIcon,
        text: 'Optimized'
      };
    }

    return {
      variant: 'warning' as const,
      icon: this.SettingsIcon,
      text: 'Basic Configuration'
    };
  });

  constructor() {
    // Initialize store and sync form when settings change
    this.initializeStore();
    this.syncFormWithSettings();
  }

  private async initializeStore() {
    if (!this.settingsStore.isInitialized()) {
      await this.settingsStore.initialize();
    }
    this.isInitialized.set(true);
  }

  private syncFormWithSettings() {
    // Watch for settings changes and update form
    const settings = this.kbSettings();
    if (settings && this.isInitialized()) {
      this.kbForm.patchValue({
        defaultEmbeddingModel: settings.default_embedding_model,
        chunkSize: settings.chunk_size,
        chunkOverlap: settings.chunk_overlap,
        searchTopK: settings.search_top_k,
        searchThreshold: settings.search_threshold,
        enableHybridSearch: settings.enable_hybrid_search,
        enableReranking: settings.enable_reranking,
        citationMode: settings.citation_mode,
      }, { emitEvent: false });
    }
  }

  // Configuration methods
  async saveConfiguration() {
    if (this.kbForm.valid) {
      const formValue = this.kbForm.value;
      const currentSettings = this.settingsStore.settings();

      if (currentSettings) {
        await this.settingsStore.updateSettings({
          kb: {
            ...currentSettings.kb,
            default_embedding_model: formValue.defaultEmbeddingModel!,
            chunk_size: formValue.chunkSize!,
            chunk_overlap: formValue.chunkOverlap!,
            search_top_k: formValue.searchTopK!,
            search_threshold: formValue.searchThreshold!,
            enable_hybrid_search: formValue.enableHybridSearch!,
            enable_reranking: formValue.enableReranking!,
            citation_mode: formValue.citationMode!,
          }
        });
      }
    }
  }

  resetConfiguration() {
    this.kbForm.reset({
      defaultEmbeddingModel: 'sentence-transformers/all-MiniLM-L6-v2',
      chunkSize: 512,
      chunkOverlap: 50,
      searchTopK: 10,
      searchThreshold: 0.7,
      enableHybridSearch: true,
      enableReranking: true,
      citationMode: 'mandatory',
    });
  }

  async testConfiguration() {
    // TODO: Implement configuration testing
    console.log('Testing KB configuration with current settings...');

    // This would test the current configuration by:
    // 1. Creating a temporary KB with test documents
    // 2. Running embedding and search tests
    // 3. Reporting performance metrics
  }

  // Utility methods
  getFieldError(fieldName: keyof KbConfigurationForm): string | null {
    const field = this.kbForm.get(fieldName);
    if (field?.invalid && field?.touched) {
      if (field.errors?.['required']) return 'This field is required';
      if (field.errors?.['min']) return `Minimum value is ${field.errors['min'].min}`;
      if (field.errors?.['max']) return `Maximum value is ${field.errors['max'].max}`;
    }
    return null;
  }

  getModelDisplayName(modelId: string): string {
    const model = this.embeddingModels.find(m => m.value === modelId);
    return model ? model.label : modelId;
  }

  formatThreshold = (value: number): string => {
    return `${(value * 100).toFixed(0)}%`;
  };
}