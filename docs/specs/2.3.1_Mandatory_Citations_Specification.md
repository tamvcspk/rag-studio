# 2.3.1 Mandatory Citations Specification

**Phase:** 2.3 Citations & Quality
**Component:** Mandatory Citations
**Priority:** HIGH
**Dependencies:** 2.1.4 Hybrid Search, 2.1.1 KB Schema, 2.2.1 Tool Registry

## Overview

Implement mandatory citation system ensuring all RAG responses include source citations with "no citation → no answer" policy, citation enrichment with metadata, and license information tracking for compliance and transparency.

## Requirements

### Functional Requirements

#### FR-2.3.1.1 Citation Requirements and Enforcement
- Enforce "no citation → no answer" policy for all RAG responses
- Require at least one valid citation for every generated answer
- Support configurable citation requirements per collection or operation
- Implement citation validation to ensure accuracy and completeness
- Provide citation fallback mechanisms for edge cases

#### FR-2.3.1.2 Citation Data Model and Storage
- Store comprehensive citation metadata including title, URL, license, version
- Support hierarchical citations (document → section → paragraph → sentence)
- Maintain citation lineage and provenance tracking
- Store citation anchors and position references within source documents
- Support citation versioning and historical tracking

#### FR-2.3.1.3 Citation Enrichment and Enhancement
- Automatically enrich citations with metadata from source documents
- Extract and normalize citation information during ingestion
- Support manual citation editing and enhancement
- Implement citation deduplication and consolidation
- Provide citation quality scoring and ranking

#### FR-2.3.1.4 Citation Formatting and Presentation
- Support multiple citation formats (APA, MLA, Chicago, IEEE, custom)
- Generate properly formatted citations for different contexts
- Support inline citations and reference lists
- Provide citation export in standard formats (BibTeX, RIS, EndNote)
- Enable customizable citation templates and styles

#### FR-2.3.1.5 Citation Validation and Quality Control
- Validate citation accuracy against source documents
- Check for broken links and missing resources
- Verify license information and usage permissions
- Implement citation completeness scoring
- Support citation audit trails and verification workflows

#### FR-2.3.1.6 License Compliance and Tracking
- Track and enforce document licensing requirements
- Support multiple license types (CC, MIT, proprietary, etc.)
- Implement usage permission validation
- Provide license compatibility checking
- Generate license compliance reports

### Non-Functional Requirements

#### NFR-2.3.1.1 Performance
- Citation generation must complete within 50ms per result
- Citation validation must not add more than 100ms to search latency
- Support concurrent citation processing for batch operations
- Memory usage for citation metadata must be optimized

#### NFR-2.3.1.2 Accuracy and Reliability
- Citation accuracy must be >99% for properly ingested documents
- No false citations or phantom references allowed
- Citation links must be validated and functional
- Support graceful degradation when citations are unavailable

#### NFR-2.3.1.3 Compliance and Auditability
- All citation operations must be logged for audit purposes
- Support compliance reporting for legal and academic requirements
- Provide citation usage statistics and analytics
- Enable citation dispute resolution and correction workflows

## Technical Specification

### Citation System Architecture

```rust
use serde::{Deserialize, Serialize};
use std::collections::HashMap;
use std::sync::Arc;
use chrono::{DateTime, Utc};

#[derive(Debug, Clone)]
pub struct CitationManager {
    config: CitationConfig,
    citation_store: Arc<dyn CitationStore>,
    license_tracker: Arc<LicenseTracker>,
    formatter: Arc<CitationFormatter>,
    validator: Arc<CitationValidator>,
    enricher: Arc<CitationEnricher>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct CitationConfig {
    pub enforce_mandatory_citations: bool,
    pub minimum_citations_per_response: usize,
    pub default_citation_format: CitationFormat,
    pub enable_license_tracking: bool,
    pub citation_validation_level: ValidationLevel,
    pub max_citation_age_days: Option<u32>,
    pub supported_license_types: Vec<LicenseType>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum CitationFormat {
    APA,
    MLA,
    Chicago,
    IEEE,
    Harvard,
    Custom(String),
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum ValidationLevel {
    None,
    Basic,      // Check required fields
    Standard,   // Basic + link validation
    Strict,     // Standard + content verification
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Citation {
    pub id: String,
    pub document_id: String,
    pub chunk_id: String,
    pub title: String,
    pub authors: Vec<String>,
    pub source_url: Option<String>,
    pub source_path: Option<String>,
    pub publication_date: Option<DateTime<Utc>>,
    pub access_date: DateTime<Utc>,
    pub license: Option<LicenseInfo>,
    pub version: Option<String>,
    pub page_number: Option<u32>,
    pub section: Option<String>,
    pub anchor: Option<String>,
    pub position: CitationPosition,
    pub quality_score: f64,
    pub metadata: HashMap<String, serde_json::Value>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct CitationPosition {
    pub start_offset: usize,
    pub end_offset: usize,
    pub line_number: Option<u32>,
    pub paragraph_number: Option<u32>,
    pub context_snippet: String,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct LicenseInfo {
    pub license_type: LicenseType,
    pub license_text: Option<String>,
    pub license_url: Option<String>,
    pub attribution_required: bool,
    pub commercial_use_allowed: bool,
    pub derivative_works_allowed: bool,
    pub share_alike_required: bool,
    pub expiration_date: Option<DateTime<Utc>>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum LicenseType {
    PublicDomain,
    CC0,
    CCBY,
    CCBYSA,
    CCBYNC,
    CCBYNCSA,
    CCBYND,
    CCBYNCND,
    MIT,
    Apache2,
    GPL,
    Proprietary,
    Unknown,
}

impl CitationManager {
    pub fn new(
        config: CitationConfig,
        citation_store: Arc<dyn CitationStore>,
        license_tracker: Arc<LicenseTracker>,
    ) -> Self {
        let formatter = Arc::new(CitationFormatter::new(&config));
        let validator = Arc::new(CitationValidator::new(&config));
        let enricher = Arc::new(CitationEnricher::new(&config));

        Self {
            config,
            citation_store,
            license_tracker,
            formatter,
            validator,
            enricher,
        }
    }

    pub async fn ensure_citations(
        &self,
        search_results: &[SearchResult],
    ) -> Result<Vec<CitedResult>, CitationError> {
        let mut cited_results = Vec::new();

        for result in search_results {
            // Get or generate citation
            let citation = self.get_or_create_citation(result).await?;

            // Validate citation
            self.validator.validate_citation(&citation).await?;

            // Check license compliance
            self.check_license_compliance(&citation).await?;

            // Create cited result
            cited_results.push(CitedResult {
                result: result.clone(),
                citation,
                compliance_status: ComplianceStatus::Compliant,
            });
        }

        // Enforce minimum citation requirement
        if cited_results.len() < self.config.minimum_citations_per_response &&
           self.config.enforce_mandatory_citations {
            return Err(CitationError::InsufficientCitations {
                required: self.config.minimum_citations_per_response,
                found: cited_results.len(),
            });
        }

        Ok(cited_results)
    }

    async fn get_or_create_citation(
        &self,
        result: &SearchResult,
    ) -> Result<Citation, CitationError> {
        // Try to get existing citation
        if let Some(citation) = self.citation_store
            .get_citation_by_chunk_id(&result.chunk_id)
            .await? {
            return Ok(citation);
        }

        // Generate new citation
        self.generate_citation(result).await
    }

    async fn generate_citation(&self, result: &SearchResult) -> Result<Citation, CitationError> {
        // Get document metadata
        let document = self.citation_store
            .get_document_metadata(&result.document_id)
            .await?
            .ok_or_else(|| CitationError::DocumentNotFound {
                document_id: result.document_id.clone(),
            })?;

        // Create base citation
        let mut citation = Citation {
            id: uuid::Uuid::new_v4().to_string(),
            document_id: result.document_id.clone(),
            chunk_id: result.chunk_id.clone(),
            title: document.title,
            authors: document.authors.unwrap_or_default(),
            source_url: document.source_url,
            source_path: document.source_path,
            publication_date: document.publication_date,
            access_date: Utc::now(),
            license: document.license,
            version: document.version,
            page_number: None,
            section: None,
            anchor: Some(format!("#{}", result.chunk_id)),
            position: CitationPosition {
                start_offset: result.start_offset.unwrap_or(0),
                end_offset: result.end_offset.unwrap_or(result.content.len()),
                line_number: None,
                paragraph_number: None,
                context_snippet: self.extract_context_snippet(&result.content),
            },
            quality_score: 1.0,
            metadata: HashMap::new(),
        };

        // Enrich citation
        self.enricher.enrich_citation(&mut citation).await?;

        // Store citation for future use
        self.citation_store.store_citation(&citation).await?;

        Ok(citation)
    }

    fn extract_context_snippet(&self, content: &str) -> String {
        // Extract meaningful context snippet (first 100 chars + ellipsis if needed)
        if content.len() <= 100 {
            content.to_string()
        } else {
            format!("{}...", &content[..97])
        }
    }

    async fn check_license_compliance(&self, citation: &Citation) -> Result<(), CitationError> {
        if let Some(license) = &citation.license {
            self.license_tracker.check_usage_compliance(license).await?;
        }
        Ok(())
    }

    pub async fn format_citations(
        &self,
        citations: &[Citation],
        format: Option<CitationFormat>,
    ) -> Result<FormattedCitations, CitationError> {
        let format = format.unwrap_or_else(|| self.config.default_citation_format.clone());
        self.formatter.format_citations(citations, &format).await
    }

    pub async fn validate_response_citations(
        &self,
        response_text: &str,
        citations: &[Citation],
    ) -> Result<CitationValidationResult, CitationError> {
        // Check that response text references all citations
        let mut referenced_citations = Vec::new();
        let mut unreferenced_citations = Vec::new();

        for citation in citations {
            if self.is_citation_referenced(response_text, citation) {
                referenced_citations.push(citation.clone());
            } else {
                unreferenced_citations.push(citation.clone());
            }
        }

        // Check for minimum citation requirement
        if referenced_citations.len() < self.config.minimum_citations_per_response {
            return Err(CitationError::InsufficientReferencedCitations {
                required: self.config.minimum_citations_per_response,
                found: referenced_citations.len(),
            });
        }

        Ok(CitationValidationResult {
            total_citations: citations.len(),
            referenced_citations: referenced_citations.len(),
            unreferenced_citations: unreferenced_citations.len(),
            compliance_score: referenced_citations.len() as f64 / citations.len() as f64,
            issues: Vec::new(),
        })
    }

    fn is_citation_referenced(&self, text: &str, citation: &Citation) -> bool {
        // Simple implementation - check if citation ID or title appears in text
        text.contains(&citation.id) ||
        text.contains(&citation.title) ||
        citation.anchor.as_ref().map(|a| text.contains(a)).unwrap_or(false)
    }

    pub async fn generate_bibliography(
        &self,
        citations: &[Citation],
        format: CitationFormat,
    ) -> Result<String, CitationError> {
        self.formatter.generate_bibliography(citations, &format).await
    }

    pub async fn export_citations(
        &self,
        citations: &[Citation],
        export_format: ExportFormat,
    ) -> Result<String, CitationError> {
        match export_format {
            ExportFormat::BibTeX => self.export_bibtex(citations).await,
            ExportFormat::RIS => self.export_ris(citations).await,
            ExportFormat::EndNote => self.export_endnote(citations).await,
            ExportFormat::JSON => Ok(serde_json::to_string_pretty(citations)?),
        }
    }

    async fn export_bibtex(&self, citations: &[Citation]) -> Result<String, CitationError> {
        let mut bibtex = String::new();

        for citation in citations {
            bibtex.push_str(&format!(
                "@article{{{},\n  title = {{{}}},\n  author = {{{}}},\n  url = {{{}}},\n  year = {{{}}},\n  note = {{Accessed: {}}}\n}}\n\n",
                citation.id,
                citation.title,
                citation.authors.join(" and "),
                citation.source_url.as_deref().unwrap_or(""),
                citation.publication_date
                    .map(|d| d.year().to_string())
                    .unwrap_or_else(|| "Unknown".to_string()),
                citation.access_date.format("%Y-%m-%d")
            ));
        }

        Ok(bibtex)
    }

    async fn export_ris(&self, citations: &[Citation]) -> Result<String, CitationError> {
        let mut ris = String::new();

        for citation in citations {
            ris.push_str(&format!(
                "TY  - ELEC\nTI  - {}\nAU  - {}\nUR  - {}\nPY  - {}\nDA  - {}\nER  - \n\n",
                citation.title,
                citation.authors.join("; "),
                citation.source_url.as_deref().unwrap_or(""),
                citation.publication_date
                    .map(|d| d.year().to_string())
                    .unwrap_or_else(|| "Unknown".to_string()),
                citation.access_date.format("%Y-%m-%d")
            ));
        }

        Ok(ris)
    }

    async fn export_endnote(&self, _citations: &[Citation]) -> Result<String, CitationError> {
        // Simplified EndNote export - full implementation would use proper EndNote format
        Ok("EndNote export not fully implemented".to_string())
    }
}

#[async_trait::async_trait]
pub trait CitationStore: Send + Sync {
    async fn get_citation_by_chunk_id(&self, chunk_id: &str) -> Result<Option<Citation>, CitationError>;
    async fn get_document_metadata(&self, document_id: &str) -> Result<Option<DocumentMetadata>, CitationError>;
    async fn store_citation(&self, citation: &Citation) -> Result<(), CitationError>;
    async fn update_citation(&self, citation: &Citation) -> Result<(), CitationError>;
    async fn delete_citation(&self, citation_id: &str) -> Result<(), CitationError>;
    async fn search_citations(&self, query: &CitationQuery) -> Result<Vec<Citation>, CitationError>;
}

#[derive(Debug, Clone)]
pub struct CitationValidator {
    config: CitationConfig,
}

impl CitationValidator {
    pub fn new(config: &CitationConfig) -> Self {
        Self {
            config: config.clone(),
        }
    }

    pub async fn validate_citation(&self, citation: &Citation) -> Result<(), CitationError> {
        match self.config.citation_validation_level {
            ValidationLevel::None => Ok(()),
            ValidationLevel::Basic => self.validate_basic(citation).await,
            ValidationLevel::Standard => self.validate_standard(citation).await,
            ValidationLevel::Strict => self.validate_strict(citation).await,
        }
    }

    async fn validate_basic(&self, citation: &Citation) -> Result<(), CitationError> {
        if citation.title.is_empty() {
            return Err(CitationError::ValidationFailed {
                citation_id: citation.id.clone(),
                reason: "Title is required".to_string(),
            });
        }

        if citation.document_id.is_empty() {
            return Err(CitationError::ValidationFailed {
                citation_id: citation.id.clone(),
                reason: "Document ID is required".to_string(),
            });
        }

        Ok(())
    }

    async fn validate_standard(&self, citation: &Citation) -> Result<(), CitationError> {
        self.validate_basic(citation).await?;

        // Validate URLs if present
        if let Some(url) = &citation.source_url {
            if !self.is_valid_url(url) {
                return Err(CitationError::ValidationFailed {
                    citation_id: citation.id.clone(),
                    reason: format!("Invalid URL: {}", url),
                });
            }
        }

        Ok(())
    }

    async fn validate_strict(&self, citation: &Citation) -> Result<(), CitationError> {
        self.validate_standard(citation).await?;

        // Additional strict validation would go here
        // e.g., verify content exists, check link accessibility, etc.

        Ok(())
    }

    fn is_valid_url(&self, url: &str) -> bool {
        url::Url::parse(url).is_ok()
    }
}

#[derive(Debug, Clone)]
pub struct CitationFormatter {
    config: CitationConfig,
}

impl CitationFormatter {
    pub fn new(config: &CitationConfig) -> Self {
        Self {
            config: config.clone(),
        }
    }

    pub async fn format_citations(
        &self,
        citations: &[Citation],
        format: &CitationFormat,
    ) -> Result<FormattedCitations, CitationError> {
        let mut formatted_citations = Vec::new();

        for citation in citations {
            let formatted = self.format_single_citation(citation, format).await?;
            formatted_citations.push(formatted);
        }

        Ok(FormattedCitations {
            citations: formatted_citations,
            format: format.clone(),
            generated_at: Utc::now(),
        })
    }

    async fn format_single_citation(
        &self,
        citation: &Citation,
        format: &CitationFormat,
    ) -> Result<String, CitationError> {
        match format {
            CitationFormat::APA => self.format_apa(citation),
            CitationFormat::MLA => self.format_mla(citation),
            CitationFormat::Chicago => self.format_chicago(citation),
            CitationFormat::IEEE => self.format_ieee(citation),
            CitationFormat::Harvard => self.format_harvard(citation),
            CitationFormat::Custom(template) => self.format_custom(citation, template),
        }
    }

    fn format_apa(&self, citation: &Citation) -> Result<String, CitationError> {
        let authors = if citation.authors.is_empty() {
            "Unknown Author".to_string()
        } else {
            citation.authors.join(", ")
        };

        let year = citation.publication_date
            .map(|d| d.year().to_string())
            .unwrap_or_else(|| "n.d.".to_string());

        let url_part = citation.source_url
            .as_ref()
            .map(|url| format!(" Retrieved from {}", url))
            .unwrap_or_default();

        Ok(format!(
            "{}. ({}). {}{}",
            authors, year, citation.title, url_part
        ))
    }

    fn format_mla(&self, citation: &Citation) -> Result<String, CitationError> {
        let authors = if citation.authors.is_empty() {
            "Unknown Author".to_string()
        } else {
            citation.authors.join(", ")
        };

        let access_date = citation.access_date.format("%d %b %Y");
        let url_part = citation.source_url
            .as_ref()
            .map(|url| format!(", {}.", url))
            .unwrap_or_default();

        Ok(format!(
            "{}. \"{}.\" Web. {}{}",
            authors, citation.title, access_date, url_part
        ))
    }

    fn format_chicago(&self, citation: &Citation) -> Result<String, CitationError> {
        // Simplified Chicago format
        Ok(format!(
            "{}, \"{},\" accessed {},{}",
            citation.authors.join(", "),
            citation.title,
            citation.access_date.format("%B %d, %Y"),
            citation.source_url
                .as_ref()
                .map(|url| format!(" {}", url))
                .unwrap_or_default()
        ))
    }

    fn format_ieee(&self, citation: &Citation) -> Result<String, CitationError> {
        Ok(format!(
            "{}, \"{},\" [Online]. Available: {}. [Accessed: {}]",
            citation.authors.join(", "),
            citation.title,
            citation.source_url.as_deref().unwrap_or("Unknown"),
            citation.access_date.format("%d-%b-%Y")
        ))
    }

    fn format_harvard(&self, citation: &Citation) -> Result<String, CitationError> {
        let year = citation.publication_date
            .map(|d| d.year().to_string())
            .unwrap_or_else(|| "Unknown".to_string());

        Ok(format!(
            "{} ({}) '{}' [Online]. Available at: {} (Accessed: {})",
            citation.authors.join(", "),
            year,
            citation.title,
            citation.source_url.as_deref().unwrap_or("Unknown"),
            citation.access_date.format("%d %B %Y")
        ))
    }

    fn format_custom(&self, citation: &Citation, template: &str) -> Result<String, CitationError> {
        // Simple template substitution - full implementation would use a template engine
        let mut result = template.to_string();
        result = result.replace("{title}", &citation.title);
        result = result.replace("{authors}", &citation.authors.join(", "));
        result = result.replace("{url}", citation.source_url.as_deref().unwrap_or(""));
        result = result.replace("{date}", &citation.access_date.format("%Y-%m-%d").to_string());
        Ok(result)
    }

    pub async fn generate_bibliography(
        &self,
        citations: &[Citation],
        format: &CitationFormat,
    ) -> Result<String, CitationError> {
        let formatted = self.format_citations(citations, format).await?;
        let mut bibliography = String::from("## References\n\n");

        for (i, citation) in formatted.citations.iter().enumerate() {
            bibliography.push_str(&format!("{}. {}\n\n", i + 1, citation));
        }

        Ok(bibliography)
    }
}

#[derive(Debug, Clone)]
pub struct CitationEnricher {
    config: CitationConfig,
}

impl CitationEnricher {
    pub fn new(config: &CitationConfig) -> Self {
        Self {
            config: config.clone(),
        }
    }

    pub async fn enrich_citation(&self, citation: &mut Citation) -> Result<(), CitationError> {
        // Calculate quality score
        citation.quality_score = self.calculate_quality_score(citation);

        // Add metadata enrichment
        self.enrich_metadata(citation).await?;

        Ok(())
    }

    fn calculate_quality_score(&self, citation: &Citation) -> f64 {
        let mut score = 0.0;
        let mut max_score = 0.0;

        // Title presence (20 points)
        max_score += 20.0;
        if !citation.title.is_empty() {
            score += 20.0;
        }

        // Authors presence (15 points)
        max_score += 15.0;
        if !citation.authors.is_empty() {
            score += 15.0;
        }

        // URL presence (10 points)
        max_score += 10.0;
        if citation.source_url.is_some() {
            score += 10.0;
        }

        // License information (10 points)
        max_score += 10.0;
        if citation.license.is_some() {
            score += 10.0;
        }

        // Publication date (5 points)
        max_score += 5.0;
        if citation.publication_date.is_some() {
            score += 5.0;
        }

        // Version information (5 points)
        max_score += 5.0;
        if citation.version.is_some() {
            score += 5.0;
        }

        // Context snippet quality (35 points)
        max_score += 35.0;
        let snippet_quality = self.assess_snippet_quality(&citation.position.context_snippet);
        score += 35.0 * snippet_quality;

        score / max_score
    }

    fn assess_snippet_quality(&self, snippet: &str) -> f64 {
        if snippet.is_empty() {
            return 0.0;
        }

        let mut quality = 0.0;

        // Length appropriateness
        if snippet.len() >= 50 && snippet.len() <= 200 {
            quality += 0.4;
        } else if snippet.len() >= 20 {
            quality += 0.2;
        }

        // Contains meaningful content (not just punctuation/whitespace)
        if snippet.chars().any(|c| c.is_alphabetic()) {
            quality += 0.3;
        }

        // Completeness (doesn't end abruptly)
        if snippet.ends_with('.') || snippet.ends_with('!') || snippet.ends_with('?') {
            quality += 0.3;
        }

        quality.min(1.0)
    }

    async fn enrich_metadata(&self, citation: &mut Citation) -> Result<(), CitationError> {
        // Add enrichment metadata
        citation.metadata.insert(
            "enriched_at".to_string(),
            serde_json::json!(Utc::now().to_rfc3339())
        );

        citation.metadata.insert(
            "enrichment_version".to_string(),
            serde_json::json!("1.0.0")
        );

        Ok(())
    }
}

// Supporting data structures
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct DocumentMetadata {
    pub id: String,
    pub title: String,
    pub authors: Option<Vec<String>>,
    pub source_url: Option<String>,
    pub source_path: Option<String>,
    pub publication_date: Option<DateTime<Utc>>,
    pub license: Option<LicenseInfo>,
    pub version: Option<String>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SearchResult {
    pub chunk_id: String,
    pub document_id: String,
    pub content: String,
    pub score: f64,
    pub start_offset: Option<usize>,
    pub end_offset: Option<usize>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct CitedResult {
    pub result: SearchResult,
    pub citation: Citation,
    pub compliance_status: ComplianceStatus,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum ComplianceStatus {
    Compliant,
    NonCompliant(String),
    Unknown,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct FormattedCitations {
    pub citations: Vec<String>,
    pub format: CitationFormat,
    pub generated_at: DateTime<Utc>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct CitationValidationResult {
    pub total_citations: usize,
    pub referenced_citations: usize,
    pub unreferenced_citations: usize,
    pub compliance_score: f64,
    pub issues: Vec<String>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct CitationQuery {
    pub document_id: Option<String>,
    pub title_contains: Option<String>,
    pub author_contains: Option<String>,
    pub license_type: Option<LicenseType>,
    pub date_range: Option<(DateTime<Utc>, DateTime<Utc>)>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum ExportFormat {
    BibTeX,
    RIS,
    EndNote,
    JSON,
}

// License tracking component
#[derive(Debug, Clone)]
pub struct LicenseTracker {
    config: CitationConfig,
}

impl LicenseTracker {
    pub fn new(config: &CitationConfig) -> Self {
        Self {
            config: config.clone(),
        }
    }

    pub async fn check_usage_compliance(
        &self,
        license: &LicenseInfo,
    ) -> Result<(), CitationError> {
        // Check if license allows current usage
        if !self.is_usage_allowed(license) {
            return Err(CitationError::LicenseViolation {
                license_type: license.license_type.clone(),
                reason: "Usage not permitted by license".to_string(),
            });
        }

        // Check attribution requirements
        if license.attribution_required {
            // In a real implementation, this would check if proper attribution is provided
        }

        Ok(())
    }

    fn is_usage_allowed(&self, license: &LicenseInfo) -> bool {
        match license.license_type {
            LicenseType::PublicDomain | LicenseType::CC0 => true,
            LicenseType::CCBY | LicenseType::CCBYSA => true,
            LicenseType::MIT | LicenseType::Apache2 => true,
            LicenseType::Proprietary => false, // Would need explicit permission
            _ => true, // Default allow for other CC licenses
        }
    }
}

#[derive(Debug, thiserror::Error)]
pub enum CitationError {
    #[error("Insufficient citations: required {required}, found {found}")]
    InsufficientCitations { required: usize, found: usize },

    #[error("Insufficient referenced citations: required {required}, found {found}")]
    InsufficientReferencedCitations { required: usize, found: usize },

    #[error("Document not found: {document_id}")]
    DocumentNotFound { document_id: String },

    #[error("Citation validation failed for {citation_id}: {reason}")]
    ValidationFailed { citation_id: String, reason: String },

    #[error("License violation: {license_type:?} - {reason}")]
    LicenseViolation { license_type: LicenseType, reason: String },

    #[error("Storage error: {error}")]
    StorageError { error: String },

    #[error("Formatting error: {error}")]
    FormattingError { error: String },

    #[error("Serialization error: {0}")]
    SerializationError(#[from] serde_json::Error),
}
```

## Implementation Details

### Citation Enforcement Strategy
- Implement mandatory citation checking before any response generation
- Support configurable citation requirements per operation type
- Provide fallback mechanisms for edge cases while maintaining compliance
- Enable citation validation pipelines for quality assurance

### License Compliance Framework
- Track comprehensive license information during document ingestion
- Implement usage permission validation for different license types
- Support license compatibility checking across multiple sources
- Provide compliance reporting and audit capabilities

### Citation Quality System
- Implement multi-factor citation quality scoring
- Support citation enrichment with automatic metadata extraction
- Provide validation at multiple levels (basic, standard, strict)
- Enable manual citation editing and enhancement workflows

## Testing Strategy

### Citation Tests
- Test citation generation for various document types and formats
- Verify "no citation → no answer" policy enforcement
- Test citation validation accuracy and completeness
- Validate citation formatting across multiple styles

### License Tests
- Test license detection and tracking accuracy
- Verify usage compliance checking for different license types
- Test attribution requirement enforcement
- Validate license compatibility analysis

### Integration Tests
- Test end-to-end citation flow from search to formatted output
- Verify integration with hybrid search and KB systems
- Test citation export functionality across formats
- Validate real-time citation validation performance

## Acceptance Criteria

### AC-2.3.1.1 Mandatory Citation System
- [ ] "No citation → no answer" policy enforced for all responses
- [ ] Minimum citation requirements configurable and validated
- [ ] Citation accuracy >99% for properly ingested documents
- [ ] Citation generation completes within 50ms per result

### AC-2.3.1.2 Citation Quality and Validation
- [ ] Multi-level citation validation (basic, standard, strict)
- [ ] Citation quality scoring and ranking functional
- [ ] Citation enrichment with metadata extraction working
- [ ] Citation completeness and accuracy verification

### AC-2.3.1.3 License Compliance
- [ ] Comprehensive license tracking and validation
- [ ] Usage permission checking for different license types
- [ ] Attribution requirement enforcement
- [ ] License compliance reporting and audit trails

### AC-2.3.1.4 Citation Formatting and Export
- [ ] Support for multiple citation formats (APA, MLA, Chicago, IEEE)
- [ ] Citation export in standard formats (BibTeX, RIS, JSON)
- [ ] Bibliography generation with proper formatting
- [ ] Custom citation templates and styling support