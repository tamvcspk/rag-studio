# 2.2.3 Communication Specification

**Phase:** 2.2 MCP Server Implementation
**Component:** Communication Protocol
**Priority:** HIGH
**Dependencies:** 2.2.2 Security, 2.2.1 Tool Registry, 1.3.4 Error Handling

## Overview

Implement simple JSON-based MCP protocol over stdio for MVP with schema versioning, basic error handling, and clear upgrade path to UDS/HTTP post-MVP, supporting reliable message passing and protocol compliance.

## Requirements

### Functional Requirements

#### FR-2.2.3.1 MCP Protocol Implementation
- Implement stdio-based MCP protocol according to specification
- Support JSON-RPC 2.0 message format for all communications
- Handle initialization handshake and capability negotiation
- Implement proper MCP tool discovery and invocation flows
- Support protocol versioning and backward compatibility

#### FR-2.2.3.2 Message Processing and Validation
- Validate all incoming messages against MCP protocol schema
- Support request/response correlation with unique IDs
- Implement proper error response formatting according to JSON-RPC
- Handle malformed messages gracefully with appropriate error responses
- Support batch requests and responses for efficiency

#### FR-2.2.3.3 Schema Versioning and Compatibility
- Implement schema versioning using serde tags for forward/backward compatibility
- Support multiple protocol versions simultaneously during transitions
- Provide automatic schema migration for minor version updates
- Handle unknown fields gracefully for future compatibility
- Support protocol feature detection and negotiation

#### FR-2.2.3.4 Error Handling and Recovery
- Implement comprehensive error handling for protocol violations
- Support automatic recovery from transient communication failures
- Provide detailed error context without sensitive information leakage
- Handle timeout scenarios with appropriate error responses
- Support graceful degradation when components are unavailable

#### FR-2.2.3.5 Performance and Buffering
- Implement efficient message buffering and parsing for stdio streams
- Support streaming for large responses without blocking
- Provide configurable timeouts for different operation types
- Implement backpressure handling to prevent buffer overflow
- Support concurrent message processing where safe

#### FR-2.2.3.6 Upgrade Path Planning
- Design clear interfaces for future UDS/HTTP transport upgrades
- Support pluggable transport layers without protocol changes
- Implement transport abstraction for easy migration
- Plan authentication and encryption upgrade paths
- Support transport-specific optimizations (batching, compression)

### Non-Functional Requirements

#### NFR-2.2.3.1 Performance
- Message processing latency must be under 1ms for protocol overhead
- Support throughput of at least 1000 messages per second
- Memory usage for message buffers must stay under 10MB
- Protocol compliance validation must complete within 100Î¼s per message

#### NFR-2.2.3.2 Reliability
- Message delivery must be reliable with proper error reporting
- Protocol state must be recoverable after communication failures
- No message loss or corruption during normal operations
- Graceful handling of partial messages and stream interruptions

#### NFR-2.2.3.3 Compatibility
- Full compliance with MCP protocol specification
- Support for standard JSON-RPC 2.0 clients and tools
- Backward compatibility with previous protocol versions
- Forward compatibility for minor protocol extensions

## Technical Specification

### MCP Protocol Implementation

```rust
use serde::{Deserialize, Serialize};
use std::collections::HashMap;
use std::sync::Arc;
use tokio::sync::{mpsc, RwLock};
use tokio::io::{AsyncBufReadExt, AsyncWriteExt, BufReader, BufWriter};

#[derive(Debug, Clone)]
pub struct McpCommunicator {
    config: CommunicationConfig,
    message_handler: Arc<MessageHandler>,
    transport: Arc<dyn Transport>,
    protocol_state: Arc<RwLock<ProtocolState>>,
    request_correlation: Arc<RwLock<HashMap<String, RequestContext>>>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct CommunicationConfig {
    pub protocol_version: String,
    pub max_message_size_bytes: usize,
    pub request_timeout_ms: u64,
    pub batch_timeout_ms: u64,
    pub max_concurrent_requests: usize,
    pub buffer_size_bytes: usize,
    pub enable_compression: bool,
    pub transport_type: TransportType,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum TransportType {
    Stdio,      // MVP
    Uds,        // Post-MVP
    Http,       // Post-MVP
    WebSocket,  // Future
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ProtocolState {
    pub initialized: bool,
    pub client_info: Option<ClientInfo>,
    pub server_capabilities: ServerCapabilities,
    pub supported_versions: Vec<String>,
    pub current_version: String,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ClientInfo {
    pub name: String,
    pub version: String,
    pub capabilities: ClientCapabilities,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ServerCapabilities {
    pub tools: Vec<ToolCapability>,
    pub resources: Vec<ResourceCapability>,
    pub prompts: Vec<PromptCapability>,
    pub logging: Option<LoggingCapability>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ToolCapability {
    pub name: String,
    pub description: String,
    pub input_schema: serde_json::Value,
}

// MCP Message Types according to JSON-RPC 2.0
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(tag = "jsonrpc")]
pub enum McpMessage {
    #[serde(rename = "2.0")]
    Request(McpRequest),
    #[serde(rename = "2.0")]
    Response(McpResponse),
    #[serde(rename = "2.0")]
    Notification(McpNotification),
    #[serde(rename = "2.0")]
    Error(McpError),
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct McpRequest {
    pub id: RequestId,
    pub method: String,
    pub params: Option<serde_json::Value>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct McpResponse {
    pub id: RequestId,
    pub result: Option<serde_json::Value>,
    pub error: Option<JsonRpcError>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct McpNotification {
    pub method: String,
    pub params: Option<serde_json::Value>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct McpError {
    pub id: Option<RequestId>,
    pub error: JsonRpcError,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum RequestId {
    String(String),
    Number(i64),
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct JsonRpcError {
    pub code: i32,
    pub message: String,
    pub data: Option<serde_json::Value>,
}

// Standard JSON-RPC error codes
pub mod error_codes {
    pub const PARSE_ERROR: i32 = -32700;
    pub const INVALID_REQUEST: i32 = -32600;
    pub const METHOD_NOT_FOUND: i32 = -32601;
    pub const INVALID_PARAMS: i32 = -32602;
    pub const INTERNAL_ERROR: i32 = -32603;

    // MCP-specific error codes
    pub const TOOL_NOT_FOUND: i32 = -32000;
    pub const TOOL_EXECUTION_ERROR: i32 = -32001;
    pub const RESOURCE_NOT_FOUND: i32 = -32002;
    pub const PROTOCOL_ERROR: i32 = -32003;
}

impl McpCommunicator {
    pub fn new(config: CommunicationConfig, transport: Arc<dyn Transport>) -> Self {
        let message_handler = Arc::new(MessageHandler::new(&config));
        let protocol_state = Arc::new(RwLock::new(ProtocolState {
            initialized: false,
            client_info: None,
            server_capabilities: ServerCapabilities::default(),
            supported_versions: vec!["1.0.0".to_string()],
            current_version: "1.0.0".to_string(),
        }));

        Self {
            config,
            message_handler,
            transport,
            protocol_state,
            request_correlation: Arc::new(RwLock::new(HashMap::new())),
        }
    }

    pub async fn start(&self) -> Result<(), CommunicationError> {
        // Initialize transport
        self.transport.initialize().await?;

        // Start message processing loop
        let (tx, mut rx) = mpsc::channel(1000);

        // Spawn message receiver
        let transport_clone = self.transport.clone();
        let tx_clone = tx.clone();
        tokio::spawn(async move {
            if let Err(e) = Self::message_receiver(transport_clone, tx_clone).await {
                tracing::error!("Message receiver error: {}", e);
            }
        });

        // Process incoming messages
        while let Some(raw_message) = rx.recv().await {
            if let Err(e) = self.process_message(raw_message).await {
                tracing::error!("Message processing error: {}", e);
            }
        }

        Ok(())
    }

    async fn message_receiver(
        transport: Arc<dyn Transport>,
        tx: mpsc::Sender<String>,
    ) -> Result<(), CommunicationError> {
        let mut reader = transport.get_reader().await?;
        let mut buffer = String::new();

        loop {
            buffer.clear();

            match reader.read_line(&mut buffer).await {
                Ok(0) => break, // EOF
                Ok(_) => {
                    if let Err(_) = tx.send(buffer.trim().to_string()).await {
                        break; // Receiver dropped
                    }
                }
                Err(e) => {
                    tracing::error!("Transport read error: {}", e);
                    break;
                }
            }
        }

        Ok(())
    }

    async fn process_message(&self, raw_message: String) -> Result<(), CommunicationError> {
        // Parse message
        let message = self.parse_message(&raw_message).await?;

        // Handle message based on type
        match message {
            McpMessage::Request(request) => {
                self.handle_request(request).await?;
            }
            McpMessage::Response(response) => {
                self.handle_response(response).await?;
            }
            McpMessage::Notification(notification) => {
                self.handle_notification(notification).await?;
            }
            McpMessage::Error(error) => {
                self.handle_error(error).await?;
            }
        }

        Ok(())
    }

    async fn parse_message(&self, raw_message: &str) -> Result<McpMessage, CommunicationError> {
        // Validate message size
        if raw_message.len() > self.config.max_message_size_bytes {
            return Err(CommunicationError::MessageTooLarge {
                size: raw_message.len(),
                max_size: self.config.max_message_size_bytes,
            });
        }

        // Parse JSON
        serde_json::from_str(raw_message).map_err(|e| CommunicationError::ParseError {
            message: raw_message.to_string(),
            error: e.to_string(),
        })
    }

    async fn handle_request(&self, request: McpRequest) -> Result<(), CommunicationError> {
        let request_id = request.id.clone();

        // Track request for correlation
        {
            let mut correlation = self.request_correlation.write().await;
            correlation.insert(
                format!("{:?}", request_id),
                RequestContext {
                    start_time: std::time::Instant::now(),
                    method: request.method.clone(),
                },
            );
        }

        // Process request based on method
        let response = match request.method.as_str() {
            "initialize" => self.handle_initialize(request.params).await,
            "tools/list" => self.handle_tools_list(request.params).await,
            "tools/call" => self.handle_tools_call(request.params).await,
            "resources/list" => self.handle_resources_list(request.params).await,
            "resources/read" => self.handle_resources_read(request.params).await,
            _ => Err(CommunicationError::MethodNotFound {
                method: request.method.clone(),
            }),
        };

        // Send response
        let mcp_response = match response {
            Ok(result) => McpResponse {
                id: request_id,
                result: Some(result),
                error: None,
            },
            Err(e) => McpResponse {
                id: request_id,
                result: None,
                error: Some(self.error_to_json_rpc_error(e)),
            },
        };

        self.send_message(McpMessage::Response(mcp_response)).await?;

        // Clean up correlation
        {
            let mut correlation = self.request_correlation.write().await;
            correlation.remove(&format!("{:?}", request_id));
        }

        Ok(())
    }

    async fn handle_initialize(
        &self,
        params: Option<serde_json::Value>,
    ) -> Result<serde_json::Value, CommunicationError> {
        let init_params: InitializeParams = if let Some(p) = params {
            serde_json::from_value(p).map_err(|e| CommunicationError::InvalidParams {
                error: e.to_string(),
            })?
        } else {
            return Err(CommunicationError::InvalidParams {
                error: "Missing initialization parameters".to_string(),
            });
        };

        // Update protocol state
        {
            let mut state = self.protocol_state.write().await;
            state.initialized = true;
            state.client_info = Some(init_params.client_info);

            // Negotiate protocol version
            if let Some(version) = init_params.protocol_version {
                if state.supported_versions.contains(&version) {
                    state.current_version = version;
                }
            }
        }

        // Return server capabilities
        let state = self.protocol_state.read().await;
        Ok(serde_json::json!({
            "protocol_version": state.current_version,
            "server_info": {
                "name": "RAG Studio MCP Server",
                "version": "1.0.0"
            },
            "capabilities": state.server_capabilities
        }))
    }

    async fn handle_tools_list(
        &self,
        _params: Option<serde_json::Value>,
    ) -> Result<serde_json::Value, CommunicationError> {
        // Get available tools from registry
        let tools = self.message_handler.get_available_tools().await?;

        Ok(serde_json::json!({
            "tools": tools
        }))
    }

    async fn handle_tools_call(
        &self,
        params: Option<serde_json::Value>,
    ) -> Result<serde_json::Value, CommunicationError> {
        let call_params: ToolCallParams = if let Some(p) = params {
            serde_json::from_value(p).map_err(|e| CommunicationError::InvalidParams {
                error: e.to_string(),
            })?
        } else {
            return Err(CommunicationError::InvalidParams {
                error: "Missing tool call parameters".to_string(),
            });
        };

        // Execute tool
        let result = self.message_handler
            .execute_tool(&call_params.name, call_params.arguments)
            .await?;

        Ok(result)
    }

    async fn send_message(&self, message: McpMessage) -> Result<(), CommunicationError> {
        let serialized = serde_json::to_string(&message)
            .map_err(|e| CommunicationError::SerializationError {
                error: e.to_string(),
            })?;

        let mut writer = self.transport.get_writer().await?;
        writer.write_all((serialized + "\n").as_bytes()).await
            .map_err(|e| CommunicationError::TransportError {
                error: e.to_string(),
            })?;

        writer.flush().await
            .map_err(|e| CommunicationError::TransportError {
                error: e.to_string(),
            })?;

        Ok(())
    }

    fn error_to_json_rpc_error(&self, error: CommunicationError) -> JsonRpcError {
        match error {
            CommunicationError::ParseError { .. } => JsonRpcError {
                code: error_codes::PARSE_ERROR,
                message: "Parse error".to_string(),
                data: Some(serde_json::json!({"details": error.to_string()})),
            },
            CommunicationError::MethodNotFound { method } => JsonRpcError {
                code: error_codes::METHOD_NOT_FOUND,
                message: format!("Method not found: {}", method),
                data: None,
            },
            CommunicationError::InvalidParams { .. } => JsonRpcError {
                code: error_codes::INVALID_PARAMS,
                message: "Invalid params".to_string(),
                data: Some(serde_json::json!({"details": error.to_string()})),
            },
            CommunicationError::ToolExecutionError { .. } => JsonRpcError {
                code: error_codes::TOOL_EXECUTION_ERROR,
                message: "Tool execution error".to_string(),
                data: Some(serde_json::json!({"details": error.to_string()})),
            },
            _ => JsonRpcError {
                code: error_codes::INTERNAL_ERROR,
                message: "Internal error".to_string(),
                data: Some(serde_json::json!({"details": error.to_string()})),
            },
        }
    }

    // Additional handler methods...
    async fn handle_response(&self, _response: McpResponse) -> Result<(), CommunicationError> {
        // Handle responses to our outgoing requests
        // For MVP, this is mainly for logging and correlation cleanup
        Ok(())
    }

    async fn handle_notification(&self, _notification: McpNotification) -> Result<(), CommunicationError> {
        // Handle notifications (one-way messages)
        // For MVP, primarily logging notifications
        Ok(())
    }

    async fn handle_error(&self, _error: McpError) -> Result<(), CommunicationError> {
        // Handle error messages
        // Log and potentially retry or escalate
        Ok(())
    }
}

// Transport abstraction for future upgrades
#[async_trait::async_trait]
pub trait Transport: Send + Sync {
    async fn initialize(&self) -> Result<(), CommunicationError>;
    async fn get_reader(&self) -> Result<Box<dyn AsyncBufReadExt + Unpin + Send>, CommunicationError>;
    async fn get_writer(&self) -> Result<Box<dyn AsyncWriteExt + Unpin + Send>, CommunicationError>;
    async fn close(&self) -> Result<(), CommunicationError>;
}

// Stdio transport implementation for MVP
pub struct StdioTransport;

#[async_trait::async_trait]
impl Transport for StdioTransport {
    async fn initialize(&self) -> Result<(), CommunicationError> {
        Ok(())
    }

    async fn get_reader(&self) -> Result<Box<dyn AsyncBufReadExt + Unpin + Send>, CommunicationError> {
        let stdin = tokio::io::stdin();
        Ok(Box::new(BufReader::new(stdin)))
    }

    async fn get_writer(&self) -> Result<Box<dyn AsyncWriteExt + Unpin + Send>, CommunicationError> {
        let stdout = tokio::io::stdout();
        Ok(Box::new(BufWriter::new(stdout)))
    }

    async fn close(&self) -> Result<(), CommunicationError> {
        Ok(())
    }
}

// Supporting data structures
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct InitializeParams {
    pub protocol_version: Option<String>,
    pub client_info: ClientInfo,
    pub capabilities: ClientCapabilities,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ClientCapabilities {
    pub roots: Option<RootsCapability>,
    pub sampling: Option<SamplingCapability>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ToolCallParams {
    pub name: String,
    pub arguments: Option<serde_json::Value>,
}

#[derive(Debug, Clone)]
pub struct RequestContext {
    pub start_time: std::time::Instant,
    pub method: String,
}

#[derive(Debug, Clone)]
pub struct MessageHandler {
    config: CommunicationConfig,
}

impl MessageHandler {
    pub fn new(config: &CommunicationConfig) -> Self {
        Self {
            config: config.clone(),
        }
    }

    pub async fn get_available_tools(&self) -> Result<Vec<ToolCapability>, CommunicationError> {
        // Return list of available tools from registry
        // This would interface with the ToolRegistry
        Ok(vec![
            ToolCapability {
                name: "kb.hybrid_search".to_string(),
                description: "Perform hybrid vector and lexical search".to_string(),
                input_schema: serde_json::json!({}), // Actual schema would be loaded
            },
            // Add other tools...
        ])
    }

    pub async fn execute_tool(
        &self,
        tool_name: &str,
        arguments: Option<serde_json::Value>,
    ) -> Result<serde_json::Value, CommunicationError> {
        // Execute tool via ToolRegistry
        // This would interface with the actual tool execution system
        Ok(serde_json::json!({"result": "placeholder"}))
    }
}

// Additional capability structures
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct RootsCapability {
    pub list_changed: bool,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SamplingCapability;

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ResourceCapability {
    pub uri: String,
    pub name: String,
    pub description: String,
    pub mime_type: String,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PromptCapability {
    pub name: String,
    pub description: String,
    pub arguments: Vec<PromptArgument>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PromptArgument {
    pub name: String,
    pub description: String,
    pub required: bool,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct LoggingCapability {
    pub level: String,
}

impl Default for ServerCapabilities {
    fn default() -> Self {
        Self {
            tools: Vec::new(),
            resources: Vec::new(),
            prompts: Vec::new(),
            logging: Some(LoggingCapability {
                level: "info".to_string(),
            }),
        }
    }
}

#[derive(Debug, thiserror::Error)]
pub enum CommunicationError {
    #[error("Parse error for message '{message}': {error}")]
    ParseError { message: String, error: String },

    #[error("Method not found: {method}")]
    MethodNotFound { method: String },

    #[error("Invalid parameters: {error}")]
    InvalidParams { error: String },

    #[error("Message too large: {size} bytes (max: {max_size})")]
    MessageTooLarge { size: usize, max_size: usize },

    #[error("Serialization error: {error}")]
    SerializationError { error: String },

    #[error("Transport error: {error}")]
    TransportError { error: String },

    #[error("Tool execution error: {error}")]
    ToolExecutionError { error: String },

    #[error("Protocol error: {error}")]
    ProtocolError { error: String },

    #[error("Timeout error: {operation}")]
    TimeoutError { operation: String },
}
```

## Implementation Details

### Protocol Compliance Strategy
- Implement full JSON-RPC 2.0 compliance for interoperability
- Support standard MCP message flows and capability negotiation
- Provide comprehensive protocol validation and error handling
- Enable easy testing with standard JSON-RPC tools

### Schema Versioning Approach
- Use semantic versioning for protocol compatibility
- Support gradual migration between protocol versions
- Implement feature detection for optional capabilities
- Provide clear upgrade paths for protocol evolution

### Transport Abstraction Design
- Design pluggable transport layer for future upgrades
- Support stdio (MVP), UDS, HTTP, and WebSocket transports
- Enable transport-specific optimizations (batching, compression)
- Maintain protocol compatibility across all transports

## Testing Strategy

### Protocol Tests
- Test MCP protocol compliance with reference implementations
- Verify JSON-RPC 2.0 compatibility with standard tools
- Test schema validation and versioning scenarios
- Validate error handling and recovery mechanisms

### Integration Tests
- Test end-to-end communication with real MCP clients
- Verify tool execution through protocol interface
- Test concurrent request handling and correlation
- Validate transport layer abstraction

### Performance Tests
- Benchmark message processing throughput and latency
- Test memory usage under high message volumes
- Measure protocol overhead and optimization opportunities
- Validate timeout and backpressure handling

## Acceptance Criteria

### AC-2.2.3.1 Protocol Implementation
- [ ] Full MCP protocol compliance demonstrated
- [ ] JSON-RPC 2.0 compatibility verified
- [ ] Initialization and capability negotiation working
- [ ] Tool discovery and execution functional

### AC-2.2.3.2 Message Processing
- [ ] Message validation and error handling comprehensive
- [ ] Request/response correlation working correctly
- [ ] Batch processing support implemented
- [ ] Protocol state management functional

### AC-2.2.3.3 Performance and Reliability
- [ ] Message processing under 1ms protocol overhead
- [ ] Support for 1000+ messages per second
- [ ] Graceful error handling and recovery
- [ ] Memory usage under 10MB for buffers

### AC-2.2.3.4 Upgrade Path
- [ ] Transport abstraction layer implemented
- [ ] Schema versioning system functional
- [ ] Clear migration path to UDS/HTTP documented
- [ ] Backward compatibility maintained