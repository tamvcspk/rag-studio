# 2.3.2 License Tracking Specification

**Phase:** 2.3 Citations & Quality
**Component:** License Tracking
**Priority:** HIGH
**Dependencies:** 2.3.1 Mandatory Citations, 2.1.3 Ingest Pipeline, 2.1.1 KB Schema

## Overview

Implement comprehensive license tracking system for document licensing information with detection and storage, compliance reporting, attribution requirements management, and usage permission validation to ensure legal compliance and proper attribution.

## Requirements

### Functional Requirements

#### FR-2.3.2.1 License Detection and Classification
- Automatically detect license information from documents during ingestion
- Support recognition of common license types (Creative Commons, MIT, Apache, GPL, proprietary)
- Parse license text and extract key permissions and restrictions
- Classify unknown licenses based on content analysis and patterns
- Handle multiple licenses per document and license compatibility analysis

#### FR-2.3.2.2 License Data Model and Storage
- Store comprehensive license metadata including type, version, permissions, restrictions
- Track license URLs, full text, and expiration dates where applicable
- Maintain license inheritance relationships for derived works
- Store license detection confidence scores and validation status
- Support license versioning and historical tracking

#### FR-2.3.2.3 Attribution Requirements Management
- Track attribution requirements and formatting specifications per license
- Generate proper attribution text based on license requirements
- Support custom attribution templates and formats
- Validate attribution completeness and accuracy
- Handle attribution aggregation for multiple sources

#### FR-2.3.2.4 Usage Permission Validation
- Validate usage permissions against license terms for different use cases
- Check commercial use permissions and restrictions
- Verify derivative work permissions and share-alike requirements
- Implement usage context analysis (internal, distribution, modification)
- Support permission escalation and approval workflows

#### FR-2.3.2.5 Compliance Reporting and Monitoring
- Generate comprehensive license compliance reports
- Track license usage patterns and potential violations
- Provide license inventory and audit capabilities
- Support compliance dashboard and alerting
- Generate attribution documentation and license acknowledgments

#### FR-2.3.2.6 License Compatibility Analysis
- Analyze license compatibility when combining multiple sources
- Detect potential license conflicts and incompatibilities
- Provide recommendations for license compliance in derived works
- Support license compatibility matrices and rule engines
- Handle complex licensing scenarios with multiple dependencies

### Non-Functional Requirements

#### NFR-2.3.2.1 Accuracy and Reliability
- License detection accuracy must be >95% for standard licenses
- License classification must handle edge cases and ambiguous licenses
- Attribution generation must be legally compliant and accurate
- Usage validation must err on the side of caution (deny by default)

#### NFR-2.3.2.2 Performance
- License detection must complete within 200ms per document
- License validation must not add more than 50ms to search operations
- Compliance reporting must generate within 5 seconds for 10K documents
- License database queries must complete within 100ms

#### NFR-2.3.2.3 Maintainability and Extensibility
- License detection rules must be easily updatable without code changes
- New license types must be addable through configuration
- License compatibility rules must be maintainable by legal experts
- System must support license template customization and localization

## Technical Specification

### License Tracking Architecture

```rust
use serde::{Deserialize, Serialize};
use std::collections::{HashMap, HashSet};
use std::sync::Arc;
use chrono::{DateTime, Utc};
use regex::Regex;

#[derive(Debug, Clone)]
pub struct LicenseTracker {
    config: LicenseTrackingConfig,
    detector: Arc<LicenseDetector>,
    validator: Arc<LicenseValidator>,
    compatibility_analyzer: Arc<CompatibilityAnalyzer>,
    attribution_generator: Arc<AttributionGenerator>,
    compliance_reporter: Arc<ComplianceReporter>,
    license_store: Arc<dyn LicenseStore>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct LicenseTrackingConfig {
    pub enable_automatic_detection: bool,
    pub detection_confidence_threshold: f64,
    pub require_explicit_license: bool,
    pub default_license_for_unknown: Option<LicenseType>,
    pub supported_license_families: Vec<LicenseFamily>,
    pub attribution_template: String,
    pub compliance_check_interval_hours: u64,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum LicenseFamily {
    CreativeCommons,
    OpenSource,
    Copyleft,
    Permissive,
    Proprietary,
    PublicDomain,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct LicenseInfo {
    pub id: String,
    pub license_type: LicenseType,
    pub license_version: Option<String>,
    pub license_text: Option<String>,
    pub license_url: Option<String>,
    pub detection_method: DetectionMethod,
    pub detection_confidence: f64,
    pub permissions: LicensePermissions,
    pub restrictions: LicenseRestrictions,
    pub attribution_requirements: AttributionRequirements,
    pub expiration_date: Option<DateTime<Utc>>,
    pub metadata: HashMap<String, serde_json::Value>,
    pub created_at: DateTime<Utc>,
    pub validated_at: Option<DateTime<Utc>>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum LicenseType {
    // Creative Commons
    CC0,
    CCBY(String),      // Version: 4.0, 3.0, etc.
    CCBYSA(String),
    CCBYNC(String),
    CCBYNCSA(String),
    CCBYND(String),
    CCBYNCND(String),

    // Open Source
    MIT,
    Apache2,
    GPL(String),       // Version: v2, v3
    LGPL(String),
    BSD(String),       // Variant: 2-clause, 3-clause

    // Proprietary
    Proprietary(String), // Custom proprietary license
    AllRightsReserved,

    // Public Domain
    PublicDomain,

    // Unknown/Other
    Unknown,
    Custom(String),
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum DetectionMethod {
    MetadataExtraction,
    TextPatternMatching,
    FileHeaderAnalysis,
    UrlReference,
    ManualAnnotation,
    InheritedFromParent,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct LicensePermissions {
    pub commercial_use: PermissionStatus,
    pub distribution: PermissionStatus,
    pub modification: PermissionStatus,
    pub private_use: PermissionStatus,
    pub patent_grant: PermissionStatus,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct LicenseRestrictions {
    pub attribution_required: bool,
    pub share_alike_required: bool,
    pub no_derivatives: bool,
    pub copyleft_required: bool,
    pub include_license_text: bool,
    pub include_copyright_notice: bool,
    pub disclose_source: bool,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum PermissionStatus {
    Allowed,
    Forbidden,
    Conditional(String),
    Unknown,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct AttributionRequirements {
    pub attribution_required: bool,
    pub attribution_format: Option<String>,
    pub include_license_notice: bool,
    pub include_source_link: bool,
    pub custom_attribution_text: Option<String>,
}

impl LicenseTracker {
    pub fn new(
        config: LicenseTrackingConfig,
        license_store: Arc<dyn LicenseStore>,
    ) -> Self {
        let detector = Arc::new(LicenseDetector::new(&config));
        let validator = Arc::new(LicenseValidator::new(&config));
        let compatibility_analyzer = Arc::new(CompatibilityAnalyzer::new(&config));
        let attribution_generator = Arc::new(AttributionGenerator::new(&config));
        let compliance_reporter = Arc::new(ComplianceReporter::new(&config));

        Self {
            config,
            detector,
            validator,
            compatibility_analyzer,
            attribution_generator,
            compliance_reporter,
            license_store,
        }
    }

    pub async fn process_document_license(
        &self,
        document_id: &str,
        document_content: &str,
        metadata: &HashMap<String, String>,
    ) -> Result<LicenseInfo, LicenseError> {
        // Try to detect license
        let detected_license = if self.config.enable_automatic_detection {
            self.detector.detect_license(document_content, metadata).await?
        } else {
            None
        };

        // Use detected license or default
        let license_info = if let Some(license) = detected_license {
            if license.detection_confidence >= self.config.detection_confidence_threshold {
                license
            } else {
                self.handle_low_confidence_detection(license).await?
            }
        } else if self.config.require_explicit_license {
            return Err(LicenseError::NoLicenseFound {
                document_id: document_id.to_string(),
            });
        } else {
            self.create_default_license(document_id).await?
        };

        // Validate license
        self.validator.validate_license(&license_info).await?;

        // Store license
        self.license_store.store_license(document_id, &license_info).await?;

        Ok(license_info)
    }

    async fn handle_low_confidence_detection(
        &self,
        mut license: LicenseInfo,
    ) -> Result<LicenseInfo, LicenseError> {
        // For low confidence detection, mark as unknown and flag for review
        license.license_type = LicenseType::Unknown;
        license.metadata.insert(
            "review_required".to_string(),
            serde_json::json!(true)
        );
        license.metadata.insert(
            "original_detection".to_string(),
            serde_json::json!(license.license_type)
        );

        Ok(license)
    }

    async fn create_default_license(&self, document_id: &str) -> Result<LicenseInfo, LicenseError> {
        let default_type = self.config.default_license_for_unknown
            .clone()
            .unwrap_or(LicenseType::AllRightsReserved);

        let license_info = LicenseInfo {
            id: uuid::Uuid::new_v4().to_string(),
            license_type: default_type,
            license_version: None,
            license_text: None,
            license_url: None,
            detection_method: DetectionMethod::InheritedFromParent,
            detection_confidence: 1.0,
            permissions: self.get_default_permissions(&LicenseType::AllRightsReserved),
            restrictions: self.get_default_restrictions(&LicenseType::AllRightsReserved),
            attribution_requirements: AttributionRequirements {
                attribution_required: true,
                attribution_format: None,
                include_license_notice: true,
                include_source_link: false,
                custom_attribution_text: None,
            },
            expiration_date: None,
            metadata: HashMap::new(),
            created_at: Utc::now(),
            validated_at: None,
        };

        Ok(license_info)
    }

    pub async fn validate_usage_permission(
        &self,
        document_id: &str,
        usage_context: &UsageContext,
    ) -> Result<UsagePermissionResult, LicenseError> {
        let license = self.license_store.get_license(document_id).await?
            .ok_or_else(|| LicenseError::LicenseNotFound {
                document_id: document_id.to_string(),
            })?;

        self.validator.validate_usage_permission(&license, usage_context).await
    }

    pub async fn generate_attribution(
        &self,
        document_ids: &[String],
    ) -> Result<AttributionText, LicenseError> {
        let mut licenses = Vec::new();

        for document_id in document_ids {
            let license = self.license_store.get_license(document_id).await?
                .ok_or_else(|| LicenseError::LicenseNotFound {
                    document_id: document_id.to_string(),
                })?;
            licenses.push((document_id.clone(), license));
        }

        self.attribution_generator.generate_attribution(&licenses).await
    }

    pub async fn analyze_license_compatibility(
        &self,
        document_ids: &[String],
        intended_use: &UsageContext,
    ) -> Result<CompatibilityAnalysis, LicenseError> {
        let mut licenses = Vec::new();

        for document_id in document_ids {
            let license = self.license_store.get_license(document_id).await?
                .ok_or_else(|| LicenseError::LicenseNotFound {
                    document_id: document_id.to_string(),
                })?;
            licenses.push(license);
        }

        self.compatibility_analyzer.analyze_compatibility(&licenses, intended_use).await
    }

    pub async fn generate_compliance_report(
        &self,
        collection_id: Option<&str>,
    ) -> Result<ComplianceReport, LicenseError> {
        self.compliance_reporter.generate_report(collection_id).await
    }

    fn get_default_permissions(&self, license_type: &LicenseType) -> LicensePermissions {
        match license_type {
            LicenseType::CC0 | LicenseType::PublicDomain => LicensePermissions {
                commercial_use: PermissionStatus::Allowed,
                distribution: PermissionStatus::Allowed,
                modification: PermissionStatus::Allowed,
                private_use: PermissionStatus::Allowed,
                patent_grant: PermissionStatus::Unknown,
            },
            LicenseType::MIT | LicenseType::Apache2 => LicensePermissions {
                commercial_use: PermissionStatus::Allowed,
                distribution: PermissionStatus::Allowed,
                modification: PermissionStatus::Allowed,
                private_use: PermissionStatus::Allowed,
                patent_grant: PermissionStatus::Conditional("With Apache2".to_string()),
            },
            LicenseType::AllRightsReserved | LicenseType::Proprietary(_) => LicensePermissions {
                commercial_use: PermissionStatus::Forbidden,
                distribution: PermissionStatus::Forbidden,
                modification: PermissionStatus::Forbidden,
                private_use: PermissionStatus::Conditional("Limited".to_string()),
                patent_grant: PermissionStatus::Forbidden,
            },
            _ => LicensePermissions {
                commercial_use: PermissionStatus::Unknown,
                distribution: PermissionStatus::Unknown,
                modification: PermissionStatus::Unknown,
                private_use: PermissionStatus::Unknown,
                patent_grant: PermissionStatus::Unknown,
            },
        }
    }

    fn get_default_restrictions(&self, license_type: &LicenseType) -> LicenseRestrictions {
        match license_type {
            LicenseType::CC0 | LicenseType::PublicDomain => LicenseRestrictions {
                attribution_required: false,
                share_alike_required: false,
                no_derivatives: false,
                copyleft_required: false,
                include_license_text: false,
                include_copyright_notice: false,
                disclose_source: false,
            },
            LicenseType::CCBY(_) => LicenseRestrictions {
                attribution_required: true,
                share_alike_required: false,
                no_derivatives: false,
                copyleft_required: false,
                include_license_text: true,
                include_copyright_notice: true,
                disclose_source: false,
            },
            LicenseType::CCBYSA(_) => LicenseRestrictions {
                attribution_required: true,
                share_alike_required: true,
                no_derivatives: false,
                copyleft_required: true,
                include_license_text: true,
                include_copyright_notice: true,
                disclose_source: false,
            },
            LicenseType::AllRightsReserved => LicenseRestrictions {
                attribution_required: true,
                share_alike_required: false,
                no_derivatives: true,
                copyleft_required: false,
                include_license_text: true,
                include_copyright_notice: true,
                disclose_source: false,
            },
            _ => LicenseRestrictions {
                attribution_required: true,
                share_alike_required: false,
                no_derivatives: false,
                copyleft_required: false,
                include_license_text: true,
                include_copyright_notice: true,
                disclose_source: false,
            },
        }
    }
}

#[derive(Debug, Clone)]
pub struct LicenseDetector {
    config: LicenseTrackingConfig,
    patterns: HashMap<LicenseType, Vec<Regex>>,
    url_patterns: HashMap<LicenseType, Vec<String>>,
}

impl LicenseDetector {
    pub fn new(config: &LicenseTrackingConfig) -> Self {
        let mut detector = Self {
            config: config.clone(),
            patterns: HashMap::new(),
            url_patterns: HashMap::new(),
        };

        detector.initialize_patterns();
        detector
    }

    fn initialize_patterns(&mut self) {
        // Creative Commons patterns
        self.add_pattern(
            LicenseType::CC0,
            vec![
                r"CC0\s+1\.0",
                r"Creative\s+Commons\s+Zero",
                r"Public\s+Domain\s+Dedication",
            ]
        );

        self.add_pattern(
            LicenseType::CCBY("4.0".to_string()),
            vec![
                r"CC\s+BY\s+4\.0",
                r"Creative\s+Commons\s+Attribution\s+4\.0",
            ]
        );

        // MIT License patterns
        self.add_pattern(
            LicenseType::MIT,
            vec![
                r"MIT\s+License",
                r"Permission\s+is\s+hereby\s+granted,\s+free\s+of\s+charge",
                r"THE\s+SOFTWARE\s+IS\s+PROVIDED\s+\"AS\s+IS\"",
            ]
        );

        // Apache patterns
        self.add_pattern(
            LicenseType::Apache2,
            vec![
                r"Apache\s+License,?\s+Version\s+2\.0",
                r"Licensed\s+under\s+the\s+Apache\s+License",
            ]
        );

        // URL patterns
        self.url_patterns.insert(
            LicenseType::CC0,
            vec![
                "https://creativecommons.org/publicdomain/zero/1.0/".to_string(),
                "http://creativecommons.org/publicdomain/zero/1.0/".to_string(),
            ]
        );

        self.url_patterns.insert(
            LicenseType::CCBY("4.0".to_string()),
            vec![
                "https://creativecommons.org/licenses/by/4.0/".to_string(),
                "http://creativecommons.org/licenses/by/4.0/".to_string(),
            ]
        );
    }

    fn add_pattern(&mut self, license_type: LicenseType, patterns: Vec<&str>) {
        let compiled_patterns: Vec<Regex> = patterns
            .into_iter()
            .filter_map(|p| Regex::new(&format!("(?i){}", p)).ok())
            .collect();

        self.patterns.insert(license_type, compiled_patterns);
    }

    pub async fn detect_license(
        &self,
        content: &str,
        metadata: &HashMap<String, String>,
    ) -> Result<Option<LicenseInfo>, LicenseError> {
        // Try metadata-based detection first
        if let Some(license) = self.detect_from_metadata(metadata).await? {
            return Ok(Some(license));
        }

        // Try content-based detection
        if let Some(license) = self.detect_from_content(content).await? {
            return Ok(Some(license));
        }

        // Try URL-based detection
        if let Some(license) = self.detect_from_urls(content).await? {
            return Ok(Some(license));
        }

        Ok(None)
    }

    async fn detect_from_metadata(
        &self,
        metadata: &HashMap<String, String>,
    ) -> Result<Option<LicenseInfo>, LicenseError> {
        // Check common metadata fields
        for (key, value) in metadata {
            if key.to_lowercase().contains("license") {
                if let Some(license_type) = self.classify_license_text(value) {
                    return Ok(Some(self.create_license_info(
                        license_type,
                        DetectionMethod::MetadataExtraction,
                        0.9,
                        Some(value.clone()),
                        None,
                    )));
                }
            }
        }

        Ok(None)
    }

    async fn detect_from_content(
        &self,
        content: &str,
    ) -> Result<Option<LicenseInfo>, LicenseError> {
        let mut best_match: Option<(LicenseType, f64)> = None;

        for (license_type, patterns) in &self.patterns {
            let mut match_score = 0.0;
            let mut total_patterns = patterns.len() as f64;

            for pattern in patterns {
                if pattern.is_match(content) {
                    match_score += 1.0;
                }
            }

            let confidence = match_score / total_patterns;

            if confidence > 0.5 {
                match best_match {
                    None => best_match = Some((license_type.clone(), confidence)),
                    Some((_, current_confidence)) if confidence > current_confidence => {
                        best_match = Some((license_type.clone(), confidence));
                    }
                    _ => {}
                }
            }
        }

        if let Some((license_type, confidence)) = best_match {
            Ok(Some(self.create_license_info(
                license_type,
                DetectionMethod::TextPatternMatching,
                confidence,
                None,
                None,
            )))
        } else {
            Ok(None)
        }
    }

    async fn detect_from_urls(
        &self,
        content: &str,
    ) -> Result<Option<LicenseInfo>, LicenseError> {
        for (license_type, urls) in &self.url_patterns {
            for url in urls {
                if content.contains(url) {
                    return Ok(Some(self.create_license_info(
                        license_type.clone(),
                        DetectionMethod::UrlReference,
                        0.95,
                        None,
                        Some(url.clone()),
                    )));
                }
            }
        }

        Ok(None)
    }

    fn classify_license_text(&self, text: &str) -> Option<LicenseType> {
        let text_lower = text.to_lowercase();

        if text_lower.contains("cc0") || text_lower.contains("creative commons zero") {
            Some(LicenseType::CC0)
        } else if text_lower.contains("cc by 4.0") {
            Some(LicenseType::CCBY("4.0".to_string()))
        } else if text_lower.contains("cc by-sa 4.0") {
            Some(LicenseType::CCBYSA("4.0".to_string()))
        } else if text_lower.contains("mit") {
            Some(LicenseType::MIT)
        } else if text_lower.contains("apache") {
            Some(LicenseType::Apache2)
        } else if text_lower.contains("all rights reserved") {
            Some(LicenseType::AllRightsReserved)
        } else if text_lower.contains("public domain") {
            Some(LicenseType::PublicDomain)
        } else {
            None
        }
    }

    fn create_license_info(
        &self,
        license_type: LicenseType,
        detection_method: DetectionMethod,
        confidence: f64,
        license_text: Option<String>,
        license_url: Option<String>,
    ) -> LicenseInfo {
        LicenseInfo {
            id: uuid::Uuid::new_v4().to_string(),
            license_type: license_type.clone(),
            license_version: self.extract_version(&license_type),
            license_text,
            license_url,
            detection_method,
            detection_confidence: confidence,
            permissions: self.get_permissions_for_type(&license_type),
            restrictions: self.get_restrictions_for_type(&license_type),
            attribution_requirements: self.get_attribution_requirements(&license_type),
            expiration_date: None,
            metadata: HashMap::new(),
            created_at: Utc::now(),
            validated_at: None,
        }
    }

    fn extract_version(&self, license_type: &LicenseType) -> Option<String> {
        match license_type {
            LicenseType::CCBY(version) |
            LicenseType::CCBYSA(version) |
            LicenseType::CCBYNC(version) |
            LicenseType::CCBYNCSA(version) |
            LicenseType::CCBYND(version) |
            LicenseType::CCBYNCND(version) => Some(version.clone()),
            LicenseType::GPL(version) |
            LicenseType::LGPL(version) |
            LicenseType::BSD(version) => Some(version.clone()),
            _ => None,
        }
    }

    fn get_permissions_for_type(&self, license_type: &LicenseType) -> LicensePermissions {
        match license_type {
            LicenseType::CC0 | LicenseType::PublicDomain => LicensePermissions {
                commercial_use: PermissionStatus::Allowed,
                distribution: PermissionStatus::Allowed,
                modification: PermissionStatus::Allowed,
                private_use: PermissionStatus::Allowed,
                patent_grant: PermissionStatus::Unknown,
            },
            LicenseType::CCBY(_) => LicensePermissions {
                commercial_use: PermissionStatus::Allowed,
                distribution: PermissionStatus::Allowed,
                modification: PermissionStatus::Allowed,
                private_use: PermissionStatus::Allowed,
                patent_grant: PermissionStatus::Unknown,
            },
            LicenseType::CCBYNC(_) | LicenseType::CCBYNCSA(_) | LicenseType::CCBYNCND(_) => LicensePermissions {
                commercial_use: PermissionStatus::Forbidden,
                distribution: PermissionStatus::Allowed,
                modification: PermissionStatus::Conditional("Non-commercial only".to_string()),
                private_use: PermissionStatus::Allowed,
                patent_grant: PermissionStatus::Unknown,
            },
            LicenseType::MIT => LicensePermissions {
                commercial_use: PermissionStatus::Allowed,
                distribution: PermissionStatus::Allowed,
                modification: PermissionStatus::Allowed,
                private_use: PermissionStatus::Allowed,
                patent_grant: PermissionStatus::Unknown,
            },
            LicenseType::Apache2 => LicensePermissions {
                commercial_use: PermissionStatus::Allowed,
                distribution: PermissionStatus::Allowed,
                modification: PermissionStatus::Allowed,
                private_use: PermissionStatus::Allowed,
                patent_grant: PermissionStatus::Allowed,
            },
            _ => LicensePermissions {
                commercial_use: PermissionStatus::Forbidden,
                distribution: PermissionStatus::Forbidden,
                modification: PermissionStatus::Forbidden,
                private_use: PermissionStatus::Conditional("Limited".to_string()),
                patent_grant: PermissionStatus::Forbidden,
            },
        }
    }

    fn get_restrictions_for_type(&self, license_type: &LicenseType) -> LicenseRestrictions {
        match license_type {
            LicenseType::CC0 | LicenseType::PublicDomain => LicenseRestrictions {
                attribution_required: false,
                share_alike_required: false,
                no_derivatives: false,
                copyleft_required: false,
                include_license_text: false,
                include_copyright_notice: false,
                disclose_source: false,
            },
            LicenseType::CCBY(_) | LicenseType::CCBYNC(_) => LicenseRestrictions {
                attribution_required: true,
                share_alike_required: false,
                no_derivatives: false,
                copyleft_required: false,
                include_license_text: true,
                include_copyright_notice: true,
                disclose_source: false,
            },
            LicenseType::CCBYSA(_) | LicenseType::CCBYNCSA(_) => LicenseRestrictions {
                attribution_required: true,
                share_alike_required: true,
                no_derivatives: false,
                copyleft_required: true,
                include_license_text: true,
                include_copyright_notice: true,
                disclose_source: false,
            },
            LicenseType::CCBYND(_) | LicenseType::CCBYNCND(_) => LicenseRestrictions {
                attribution_required: true,
                share_alike_required: false,
                no_derivatives: true,
                copyleft_required: false,
                include_license_text: true,
                include_copyright_notice: true,
                disclose_source: false,
            },
            _ => LicenseRestrictions {
                attribution_required: true,
                share_alike_required: false,
                no_derivatives: true,
                copyleft_required: false,
                include_license_text: true,
                include_copyright_notice: true,
                disclose_source: false,
            },
        }
    }

    fn get_attribution_requirements(&self, license_type: &LicenseType) -> AttributionRequirements {
        match license_type {
            LicenseType::CC0 | LicenseType::PublicDomain => AttributionRequirements {
                attribution_required: false,
                attribution_format: None,
                include_license_notice: false,
                include_source_link: false,
                custom_attribution_text: None,
            },
            LicenseType::CCBY(_) | LicenseType::CCBYSA(_) | LicenseType::CCBYNC(_) |
            LicenseType::CCBYNCSA(_) | LicenseType::CCBYND(_) | LicenseType::CCBYNCND(_) => {
                AttributionRequirements {
                    attribution_required: true,
                    attribution_format: Some("Author Name, Title, License".to_string()),
                    include_license_notice: true,
                    include_source_link: true,
                    custom_attribution_text: None,
                }
            },
            _ => AttributionRequirements {
                attribution_required: true,
                attribution_format: None,
                include_license_notice: true,
                include_source_link: false,
                custom_attribution_text: None,
            },
        }
    }
}

// Additional supporting components would be implemented similarly...
#[derive(Debug, Clone)]
pub struct LicenseValidator {
    config: LicenseTrackingConfig,
}

#[derive(Debug, Clone)]
pub struct CompatibilityAnalyzer {
    config: LicenseTrackingConfig,
}

#[derive(Debug, Clone)]
pub struct AttributionGenerator {
    config: LicenseTrackingConfig,
}

#[derive(Debug, Clone)]
pub struct ComplianceReporter {
    config: LicenseTrackingConfig,
}

// Supporting data structures
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct UsageContext {
    pub usage_type: UsageType,
    pub commercial: bool,
    pub distribution: bool,
    pub modification: bool,
    pub public_display: bool,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum UsageType {
    InternalResearch,
    PublicDistribution,
    CommercialProduct,
    EducationalUse,
    DerivativeWork,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct UsagePermissionResult {
    pub permitted: bool,
    pub restrictions: Vec<String>,
    pub required_attributions: Vec<String>,
    pub compliance_notes: Vec<String>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct AttributionText {
    pub full_attribution: String,
    pub short_attribution: String,
    pub license_notices: Vec<String>,
    pub bibliography_entries: Vec<String>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct CompatibilityAnalysis {
    pub compatible: bool,
    pub conflicts: Vec<LicenseConflict>,
    pub recommended_license: Option<LicenseType>,
    pub compliance_requirements: Vec<String>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct LicenseConflict {
    pub license1: LicenseType,
    pub license2: LicenseType,
    pub conflict_type: ConflictType,
    pub description: String,
    pub resolution: Option<String>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum ConflictType {
    ShareAlikeMismatch,
    CommercialUseConflict,
    CopyleftIncompatibility,
    DerivativeWorkRestriction,
    AttributionConflict,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ComplianceReport {
    pub report_id: String,
    pub generated_at: DateTime<Utc>,
    pub collection_id: Option<String>,
    pub total_documents: usize,
    pub license_distribution: HashMap<LicenseType, usize>,
    pub compliance_issues: Vec<ComplianceIssue>,
    pub attribution_summary: AttributionSummary,
    pub recommendations: Vec<String>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ComplianceIssue {
    pub issue_type: ComplianceIssueType,
    pub document_ids: Vec<String>,
    pub description: String,
    pub severity: IssueSeverity,
    pub resolution: Option<String>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum ComplianceIssueType {
    MissingLicense,
    IncompatibleLicenses,
    MissingAttribution,
    LicenseViolation,
    UnknownLicense,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum IssueSeverity {
    Low,
    Medium,
    High,
    Critical,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct AttributionSummary {
    pub total_attributions_required: usize,
    pub attributions_provided: usize,
    pub missing_attributions: Vec<String>,
    pub suggested_attribution_text: String,
}

#[async_trait::async_trait]
pub trait LicenseStore: Send + Sync {
    async fn store_license(&self, document_id: &str, license: &LicenseInfo) -> Result<(), LicenseError>;
    async fn get_license(&self, document_id: &str) -> Result<Option<LicenseInfo>, LicenseError>;
    async fn update_license(&self, document_id: &str, license: &LicenseInfo) -> Result<(), LicenseError>;
    async fn delete_license(&self, document_id: &str) -> Result<(), LicenseError>;
    async fn search_licenses(&self, query: &LicenseQuery) -> Result<Vec<(String, LicenseInfo)>, LicenseError>;
    async fn get_license_statistics(&self) -> Result<LicenseStatistics, LicenseError>;
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct LicenseQuery {
    pub license_type: Option<LicenseType>,
    pub license_family: Option<LicenseFamily>,
    pub commercial_use_allowed: Option<bool>,
    pub attribution_required: Option<bool>,
    pub date_range: Option<(DateTime<Utc>, DateTime<Utc>)>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct LicenseStatistics {
    pub total_documents: usize,
    pub licenses_by_type: HashMap<LicenseType, usize>,
    pub licenses_by_family: HashMap<LicenseFamily, usize>,
    pub commercial_use_allowed: usize,
    pub attribution_required: usize,
    pub unknown_licenses: usize,
}

#[derive(Debug, thiserror::Error)]
pub enum LicenseError {
    #[error("No license found for document: {document_id}")]
    NoLicenseFound { document_id: String },

    #[error("License not found for document: {document_id}")]
    LicenseNotFound { document_id: String },

    #[error("License detection failed: {reason}")]
    DetectionFailed { reason: String },

    #[error("License validation failed: {reason}")]
    ValidationFailed { reason: String },

    #[error("License compatibility conflict: {reason}")]
    CompatibilityConflict { reason: String },

    #[error("Attribution generation failed: {reason}")]
    AttributionFailed { reason: String },

    #[error("Storage error: {error}")]
    StorageError { error: String },

    #[error("Parsing error: {error}")]
    ParsingError { error: String },
}
```

## Implementation Details

### License Detection Strategy
- Use multi-method detection: metadata extraction, text pattern matching, URL references
- Implement confidence scoring and threshold-based acceptance
- Support manual review workflows for low-confidence detections
- Enable custom pattern addition for domain-specific licenses

### Compliance Framework
- Implement usage permission validation for different contexts
- Support license compatibility analysis for combined works
- Provide compliance reporting with actionable recommendations
- Enable attribution generation with proper formatting

### Attribution Management
- Generate proper attribution text based on license requirements
- Support multiple attribution formats and templates
- Handle attribution aggregation for multiple sources
- Provide bibliography and acknowledgment generation

## Testing Strategy

### Detection Tests
- Test license detection accuracy across various document formats
- Verify pattern matching for all supported license types
- Test confidence scoring and threshold behavior
- Validate metadata extraction and URL recognition

### Compliance Tests
- Test usage permission validation for different scenarios
- Verify license compatibility analysis accuracy
- Test attribution generation for various license combinations
- Validate compliance reporting completeness

### Integration Tests
- Test end-to-end license tracking from ingestion to compliance
- Verify integration with citation system and search results
- Test real-time license validation performance
- Validate license database operations and queries

## Acceptance Criteria

### AC-2.3.2.1 License Detection and Classification
- [ ] License detection accuracy >95% for standard licenses
- [ ] Support for all major license families (CC, OSI, proprietary)
- [ ] Confidence-based detection with configurable thresholds
- [ ] Custom license pattern addition without code changes

### AC-2.3.2.2 Usage Permission Validation
- [ ] Accurate usage permission checking for different contexts
- [ ] Commercial use validation and restriction enforcement
- [ ] Derivative work permission analysis
- [ ] Permission escalation and approval workflows

### AC-2.3.2.3 Attribution and Compliance
- [ ] Proper attribution text generation based on license requirements
- [ ] License compatibility analysis with conflict detection
- [ ] Comprehensive compliance reporting and monitoring
- [ ] Attribution aggregation and bibliography generation

### AC-2.3.2.4 Performance and Integration
- [ ] License detection completes within 200ms per document
- [ ] License validation adds <50ms to search operations
- [ ] Integration with mandatory citations system
- [ ] Real-time compliance monitoring and alerting