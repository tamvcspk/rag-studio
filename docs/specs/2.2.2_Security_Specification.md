# 2.2.2 Security Specification

**Phase:** 2.2 MCP Server Implementation
**Component:** Security & Isolation
**Priority:** HIGH
**Dependencies:** 2.2.1 Tool Registry, 1.3.4 Error Handling, 1.2.1 AppState

## Overview

Implement basic subprocess isolation, input validation, and security boundaries for the MCP server with process isolation, JSON communication over stdio, and basic input sanitization for MVP, with clear upgrade path to full sandbox security.

## Requirements

### Functional Requirements

#### FR-2.2.2.1 Process Isolation
- Implement MCP server as isolated subprocess with no shared memory access
- Support clean process startup and shutdown with graceful termination
- Implement process supervision with automatic restart on crashes
- Provide process health monitoring and resource usage tracking
- Support configurable process isolation levels for different environments

#### FR-2.2.2.2 Communication Security
- Use JSON communication over stdio for secure message passing
- Implement message validation and sanitization for all inputs
- Support message size limits and rate limiting to prevent abuse
- Provide secure error handling without information leakage
- Implement communication timeout and retry mechanisms

#### FR-2.2.2.3 Input Validation and Sanitization
- Validate all JSON inputs against strict schemas before processing
- Sanitize string inputs to prevent injection attacks
- Implement parameter bounds checking and type validation
- Support custom validation rules for domain-specific inputs
- Provide comprehensive error reporting for validation failures

#### FR-2.2.2.4 Capability-Based Access Control
- Implement capability-based permissions for tool operations
- Support role-based access control with predefined security levels
- Provide escalation mechanisms for privileged operations
- Implement audit logging for all security-relevant actions
- Support dynamic permission updates without process restart

#### FR-2.2.2.5 Resource Management and Limits
- Implement memory usage limits and monitoring for subprocess
- Support CPU time limits and execution timeouts
- Provide disk space quotas and file access restrictions
- Implement network access controls for air-gapped mode
- Support configurable resource limits per operation type

#### FR-2.2.2.6 Security Monitoring and Logging
- Log all security-relevant events with structured format
- Implement intrusion detection for suspicious activity patterns
- Support real-time security alerts and notifications
- Provide comprehensive audit trails for compliance
- Implement log rotation and secure storage

### Non-Functional Requirements

#### NFR-2.2.2.1 Security
- All inputs must be validated and sanitized before processing
- Process isolation must prevent unauthorized access to host system
- No sensitive information should be logged or exposed in error messages
- Security controls must not be bypassable by malicious inputs

#### NFR-2.2.2.2 Performance
- Security validation overhead must be under 5ms per operation
- Process isolation must not impact operation latency by more than 10ms
- Resource monitoring must consume less than 1% of system resources
- Security logging must not impact system performance

#### NFR-2.2.2.3 Reliability
- Security failures must not crash the MCP server process
- Process supervision must ensure 99.9% uptime
- Security controls must be fail-safe (deny by default)
- Recovery procedures must maintain security boundaries

## Technical Specification

### Security Architecture

```rust
use serde::{Deserialize, Serialize};
use std::collections::HashMap;
use std::sync::Arc;
use tokio::sync::RwLock;
use tokio::process::{Child, Command};

#[derive(Debug, Clone)]
pub struct SecurityManager {
    config: SecurityConfig,
    access_control: Arc<RwLock<AccessController>>,
    resource_monitor: Arc<ResourceMonitor>,
    audit_logger: Arc<AuditLogger>,
    validator: Arc<InputValidator>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SecurityConfig {
    pub isolation_level: IsolationLevel,
    pub max_memory_mb: usize,
    pub max_cpu_time_seconds: u64,
    pub max_disk_usage_mb: usize,
    pub enable_network_access: bool,
    pub audit_log_level: AuditLevel,
    pub rate_limit_requests_per_minute: usize,
    pub max_message_size_bytes: usize,
    pub security_policy: SecurityPolicy,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum IsolationLevel {
    Process,     // MVP: Basic process isolation
    Sandbox,     // Post-MVP: Full sandbox with seccomp/AppArmor
    Container,   // Future: Container-based isolation
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum AuditLevel {
    None,
    Critical,
    Standard,
    Verbose,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SecurityPolicy {
    pub allowed_capabilities: Vec<String>,
    pub forbidden_operations: Vec<String>,
    pub required_permissions: HashMap<String, Permission>,
    pub escalation_rules: Vec<EscalationRule>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum Permission {
    ReadOnly,
    ReadWrite,
    Admin,
    System,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct EscalationRule {
    pub operation: String,
    pub required_permission: Permission,
    pub requires_confirmation: bool,
    pub audit_required: bool,
}

#[derive(Debug, Clone)]
pub struct ProcessIsolation {
    child_process: Option<Child>,
    config: ProcessConfig,
    monitor: Arc<ProcessMonitor>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ProcessConfig {
    pub working_directory: String,
    pub environment_variables: HashMap<String, String>,
    pub allowed_file_paths: Vec<String>,
    pub network_isolation: bool,
    pub resource_limits: ResourceLimits,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ResourceLimits {
    pub max_memory_bytes: usize,
    pub max_cpu_time_ms: u64,
    pub max_file_descriptors: usize,
    pub max_processes: usize,
}

impl SecurityManager {
    pub fn new(config: SecurityConfig) -> Self {
        let access_control = Arc::new(RwLock::new(AccessController::new(&config.security_policy)));
        let resource_monitor = Arc::new(ResourceMonitor::new(&config));
        let audit_logger = Arc::new(AuditLogger::new(&config));
        let validator = Arc::new(InputValidator::new(&config));

        Self {
            config,
            access_control,
            resource_monitor,
            audit_logger,
            validator,
        }
    }

    pub async fn validate_operation(
        &self,
        operation: &str,
        input: &serde_json::Value,
        context: &SecurityContext,
    ) -> Result<ValidationResult, SecurityError> {
        // Check rate limits
        self.check_rate_limits(context).await?;

        // Validate input
        let validation_result = self.validator.validate_input(operation, input).await?;

        // Check permissions
        self.check_permissions(operation, context).await?;

        // Log security event
        self.audit_logger.log_operation_attempt(operation, context, true).await;

        Ok(validation_result)
    }

    pub async fn check_permissions(
        &self,
        operation: &str,
        context: &SecurityContext,
    ) -> Result<(), SecurityError> {
        let access_control = self.access_control.read().await;

        if !access_control.is_operation_allowed(operation, &context.permissions) {
            self.audit_logger.log_permission_denied(operation, context).await;
            return Err(SecurityError::PermissionDenied {
                operation: operation.to_string(),
                required_permission: access_control.get_required_permission(operation),
                current_permission: context.permissions.clone(),
            });
        }

        // Check for escalation requirements
        if let Some(escalation) = access_control.get_escalation_rule(operation) {
            if escalation.requires_confirmation {
                // For MVP, we'll skip interactive confirmation
                // Post-MVP: implement user confirmation mechanism
                self.audit_logger.log_escalation_bypassed(operation, context).await;
            }
        }

        Ok(())
    }

    async fn check_rate_limits(&self, context: &SecurityContext) -> Result<(), SecurityError> {
        // Simple rate limiting for MVP
        // Post-MVP: implement proper rate limiting with sliding windows
        if context.requests_this_minute >= self.config.rate_limit_requests_per_minute {
            return Err(SecurityError::RateLimitExceeded {
                limit: self.config.rate_limit_requests_per_minute,
                current: context.requests_this_minute,
            });
        }
        Ok(())
    }

    pub async fn create_secure_process(
        &self,
        executable_path: &str,
        args: Vec<String>,
    ) -> Result<ProcessIsolation, SecurityError> {
        let process_config = ProcessConfig {
            working_directory: "/tmp/mcp_workspace".to_string(), // Restricted directory
            environment_variables: HashMap::new(), // Minimal environment
            allowed_file_paths: vec![
                "/tmp/mcp_workspace".to_string(),
                // Add other necessary paths
            ],
            network_isolation: !self.config.enable_network_access,
            resource_limits: ResourceLimits {
                max_memory_bytes: self.config.max_memory_mb * 1024 * 1024,
                max_cpu_time_ms: self.config.max_cpu_time_seconds * 1000,
                max_file_descriptors: 64,
                max_processes: 1,
            },
        };

        let mut command = Command::new(executable_path);
        command.args(args);

        // Set resource limits (platform-specific)
        #[cfg(unix)]
        {
            use std::os::unix::process::CommandExt;
            command.pre_exec(|| {
                // Set process limits
                // This is a simplified example - full implementation would use libc
                Ok(())
            });
        }

        // Redirect stdin/stdout for communication
        command.stdin(std::process::Stdio::piped());
        command.stdout(std::process::Stdio::piped());
        command.stderr(std::process::Stdio::piped());

        let child = command.spawn()
            .map_err(|e| SecurityError::ProcessCreationFailed {
                executable: executable_path.to_string(),
                error: e.to_string(),
            })?;

        let monitor = Arc::new(ProcessMonitor::new(child.id(), &process_config));

        Ok(ProcessIsolation {
            child_process: Some(child),
            config: process_config,
            monitor,
        })
    }
}

#[derive(Debug, Clone)]
pub struct AccessController {
    policy: SecurityPolicy,
    permission_cache: HashMap<String, Permission>,
}

impl AccessController {
    pub fn new(policy: &SecurityPolicy) -> Self {
        Self {
            policy: policy.clone(),
            permission_cache: HashMap::new(),
        }
    }

    pub fn is_operation_allowed(&self, operation: &str, permissions: &[Permission]) -> bool {
        if let Some(required_permission) = self.policy.required_permissions.get(operation) {
            permissions.iter().any(|p| self.permission_sufficient(p, required_permission))
        } else {
            // Default deny for unknown operations
            false
        }
    }

    pub fn get_required_permission(&self, operation: &str) -> Option<Permission> {
        self.policy.required_permissions.get(operation).cloned()
    }

    pub fn get_escalation_rule(&self, operation: &str) -> Option<&EscalationRule> {
        self.policy.escalation_rules.iter()
            .find(|rule| rule.operation == operation)
    }

    fn permission_sufficient(&self, current: &Permission, required: &Permission) -> bool {
        use Permission::*;
        match (current, required) {
            (System, _) => true,
            (Admin, Admin) | (Admin, ReadWrite) | (Admin, ReadOnly) => true,
            (ReadWrite, ReadWrite) | (ReadWrite, ReadOnly) => true,
            (ReadOnly, ReadOnly) => true,
            _ => false,
        }
    }
}

#[derive(Debug, Clone)]
pub struct InputValidator {
    config: SecurityConfig,
    schemas: HashMap<String, serde_json::Value>,
    sanitizer: InputSanitizer,
}

impl InputValidator {
    pub fn new(config: &SecurityConfig) -> Self {
        Self {
            config: config.clone(),
            schemas: HashMap::new(),
            sanitizer: InputSanitizer::new(),
        }
    }

    pub async fn validate_input(
        &self,
        operation: &str,
        input: &serde_json::Value,
    ) -> Result<ValidationResult, SecurityError> {
        // Check message size
        let serialized = serde_json::to_string(input)
            .map_err(|e| SecurityError::ValidationFailed {
                reason: format!("JSON serialization failed: {}", e),
            })?;

        if serialized.len() > self.config.max_message_size_bytes {
            return Err(SecurityError::MessageTooLarge {
                size: serialized.len(),
                max_size: self.config.max_message_size_bytes,
            });
        }

        // Validate against schema
        if let Some(schema) = self.schemas.get(operation) {
            self.validate_against_schema(input, schema)?;
        }

        // Sanitize input
        let sanitized_input = self.sanitizer.sanitize(input)?;

        Ok(ValidationResult {
            original_input: input.clone(),
            sanitized_input,
            validation_warnings: Vec::new(),
        })
    }

    fn validate_against_schema(
        &self,
        input: &serde_json::Value,
        schema: &serde_json::Value,
    ) -> Result<(), SecurityError> {
        use jsonschema::JSONSchema;

        let validator = JSONSchema::compile(schema)
            .map_err(|e| SecurityError::ValidationFailed {
                reason: format!("Schema compilation failed: {}", e),
            })?;

        if let Err(errors) = validator.validate(input) {
            let error_messages: Vec<String> = errors.map(|e| e.to_string()).collect();
            return Err(SecurityError::ValidationFailed {
                reason: format!("Schema validation failed: {}", error_messages.join(", ")),
            });
        }

        Ok(())
    }
}

#[derive(Debug, Clone)]
pub struct InputSanitizer;

impl InputSanitizer {
    pub fn new() -> Self {
        Self
    }

    pub fn sanitize(&self, input: &serde_json::Value) -> Result<serde_json::Value, SecurityError> {
        match input {
            serde_json::Value::String(s) => Ok(serde_json::Value::String(self.sanitize_string(s))),
            serde_json::Value::Array(arr) => {
                let sanitized: Result<Vec<_>, _> = arr.iter()
                    .map(|v| self.sanitize(v))
                    .collect();
                Ok(serde_json::Value::Array(sanitized?))
            }
            serde_json::Value::Object(obj) => {
                let sanitized: Result<serde_json::Map<_, _>, _> = obj.iter()
                    .map(|(k, v)| Ok((k.clone(), self.sanitize(v)?)))
                    .collect();
                Ok(serde_json::Value::Object(sanitized?))
            }
            other => Ok(other.clone()),
        }
    }

    fn sanitize_string(&self, input: &str) -> String {
        // Remove potentially dangerous characters
        input.chars()
            .filter(|c| !self.is_dangerous_char(*c))
            .take(10000) // Limit string length
            .collect()
    }

    fn is_dangerous_char(&self, c: char) -> bool {
        // Filter out control characters and potential injection vectors
        c.is_control() || matches!(c, '\x00'..='\x1F' | '\x7F')
    }
}

#[derive(Debug, Clone)]
pub struct ResourceMonitor {
    limits: ResourceLimits,
    current_usage: Arc<RwLock<ResourceUsage>>,
}

#[derive(Debug, Clone, Default)]
pub struct ResourceUsage {
    pub memory_bytes: usize,
    pub cpu_time_ms: u64,
    pub file_descriptors: usize,
    pub processes: usize,
}

impl ResourceMonitor {
    pub fn new(config: &SecurityConfig) -> Self {
        Self {
            limits: ResourceLimits {
                max_memory_bytes: config.max_memory_mb * 1024 * 1024,
                max_cpu_time_ms: config.max_cpu_time_seconds * 1000,
                max_file_descriptors: 64,
                max_processes: 1,
            },
            current_usage: Arc::new(RwLock::new(ResourceUsage::default())),
        }
    }

    pub async fn check_limits(&self) -> Result<(), SecurityError> {
        let usage = self.current_usage.read().await;

        if usage.memory_bytes > self.limits.max_memory_bytes {
            return Err(SecurityError::ResourceLimitExceeded {
                resource: "memory".to_string(),
                current: usage.memory_bytes,
                limit: self.limits.max_memory_bytes,
            });
        }

        if usage.cpu_time_ms > self.limits.max_cpu_time_ms {
            return Err(SecurityError::ResourceLimitExceeded {
                resource: "cpu_time".to_string(),
                current: usage.cpu_time_ms as usize,
                limit: self.limits.max_cpu_time_ms as usize,
            });
        }

        Ok(())
    }

    pub async fn update_usage(&self, new_usage: ResourceUsage) {
        let mut usage = self.current_usage.write().await;
        *usage = new_usage;
    }
}

#[derive(Debug, Clone)]
pub struct AuditLogger {
    config: SecurityConfig,
}

impl AuditLogger {
    pub fn new(config: &SecurityConfig) -> Self {
        Self {
            config: config.clone(),
        }
    }

    pub async fn log_operation_attempt(
        &self,
        operation: &str,
        context: &SecurityContext,
        success: bool,
    ) {
        if matches!(self.config.audit_log_level, AuditLevel::None) {
            return;
        }

        let log_entry = AuditLogEntry {
            timestamp: chrono::Utc::now(),
            event_type: AuditEventType::OperationAttempt,
            operation: operation.to_string(),
            user_context: context.user_id.clone(),
            success,
            details: serde_json::json!({
                "permissions": context.permissions,
                "source_ip": context.source_ip
            }),
        };

        tracing::info!(
            "AUDIT: {} - {} - {} - {}",
            log_entry.event_type,
            operation,
            if success { "SUCCESS" } else { "FAILED" },
            context.user_id.as_deref().unwrap_or("unknown")
        );

        // In production, send to secure audit log storage
    }

    pub async fn log_permission_denied(&self, operation: &str, context: &SecurityContext) {
        let log_entry = AuditLogEntry {
            timestamp: chrono::Utc::now(),
            event_type: AuditEventType::PermissionDenied,
            operation: operation.to_string(),
            user_context: context.user_id.clone(),
            success: false,
            details: serde_json::json!({
                "permissions": context.permissions,
                "source_ip": context.source_ip
            }),
        };

        tracing::warn!(
            "SECURITY: Permission denied - {} - {}",
            operation,
            context.user_id.as_deref().unwrap_or("unknown")
        );
    }

    pub async fn log_escalation_bypassed(&self, operation: &str, context: &SecurityContext) {
        tracing::warn!(
            "SECURITY: Escalation bypassed (MVP) - {} - {}",
            operation,
            context.user_id.as_deref().unwrap_or("unknown")
        );
    }
}

// Supporting data structures
#[derive(Debug, Clone)]
pub struct SecurityContext {
    pub user_id: Option<String>,
    pub permissions: Vec<Permission>,
    pub source_ip: Option<String>,
    pub requests_this_minute: usize,
    pub session_id: Option<String>,
}

#[derive(Debug, Clone)]
pub struct ValidationResult {
    pub original_input: serde_json::Value,
    pub sanitized_input: serde_json::Value,
    pub validation_warnings: Vec<String>,
}

#[derive(Debug, Clone)]
pub struct ProcessMonitor {
    process_id: u32,
    config: ProcessConfig,
}

impl ProcessMonitor {
    pub fn new(process_id: u32, config: &ProcessConfig) -> Self {
        Self {
            process_id,
            config: config.clone(),
        }
    }

    pub async fn get_resource_usage(&self) -> Result<ResourceUsage, SecurityError> {
        // Platform-specific implementation to get process resource usage
        // This is simplified for MVP
        Ok(ResourceUsage::default())
    }
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct AuditLogEntry {
    pub timestamp: chrono::DateTime<chrono::Utc>,
    pub event_type: AuditEventType,
    pub operation: String,
    pub user_context: Option<String>,
    pub success: bool,
    pub details: serde_json::Value,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum AuditEventType {
    OperationAttempt,
    PermissionDenied,
    ResourceLimitExceeded,
    SecurityViolation,
    ProcessCreated,
    ProcessTerminated,
}

#[derive(Debug, thiserror::Error)]
pub enum SecurityError {
    #[error("Permission denied for operation {operation}: requires {required_permission:?}, have {current_permission:?}")]
    PermissionDenied {
        operation: String,
        required_permission: Option<Permission>,
        current_permission: Vec<Permission>,
    },

    #[error("Rate limit exceeded: {current}/{limit} requests per minute")]
    RateLimitExceeded { limit: usize, current: usize },

    #[error("Validation failed: {reason}")]
    ValidationFailed { reason: String },

    #[error("Message too large: {size} bytes (max: {max_size})")]
    MessageTooLarge { size: usize, max_size: usize },

    #[error("Resource limit exceeded for {resource}: {current}/{limit}")]
    ResourceLimitExceeded {
        resource: String,
        current: usize,
        limit: usize,
    },

    #[error("Process creation failed for {executable}: {error}")]
    ProcessCreationFailed { executable: String, error: String },

    #[error("Security violation: {details}")]
    SecurityViolation { details: String },
}
```

## Implementation Details

### Process Isolation Strategy
- Use basic process isolation for MVP with subprocess spawning
- Implement resource limits using platform-specific APIs
- Support clean process lifecycle management with supervision
- Provide upgrade path to full sandboxing (seccomp/AppArmor/JobObject)

### Input Validation Framework
- Implement comprehensive JSON schema validation
- Support input sanitization for injection prevention
- Provide configurable validation rules per operation
- Enable real-time validation feedback for development

### Access Control System
- Use capability-based permissions with role hierarchy
- Support dynamic permission updates during runtime
- Implement escalation mechanisms for privileged operations
- Provide audit trail for all security decisions

## Testing Strategy

### Security Tests
- Test input validation with malicious payloads
- Verify process isolation boundaries
- Test access control enforcement
- Validate audit logging accuracy

### Penetration Tests
- Attempt privilege escalation attacks
- Test injection vulnerabilities
- Verify resource limit enforcement
- Test communication security

### Performance Tests
- Benchmark security validation overhead
- Test concurrent security operations
- Measure resource monitoring impact
- Validate security logging performance

## Acceptance Criteria

### AC-2.2.2.1 Process Isolation
- [ ] MCP server runs in isolated subprocess
- [ ] No shared memory access between processes
- [ ] Clean process startup and shutdown
- [ ] Resource limits enforced and monitored

### AC-2.2.2.2 Input Security
- [ ] All inputs validated against schemas
- [ ] Input sanitization prevents injection attacks
- [ ] Message size and rate limits enforced
- [ ] Comprehensive error handling without leakage

### AC-2.2.2.3 Access Control
- [ ] Capability-based permissions implemented
- [ ] Operation authorization working correctly
- [ ] Audit logging for security events
- [ ] Resource usage monitoring functional

### AC-2.2.2.4 Performance and Reliability
- [ ] Security overhead under 5ms per operation
- [ ] Process supervision ensures high uptime
- [ ] Security controls are fail-safe
- [ ] No performance impact from monitoring