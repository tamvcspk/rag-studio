# AppState Specification (1.2.1)

**Version:** 1.0
**Date:** September 16, 2025
**Status:** Draft
**Phase:** 1.2 - State Management (Simplified MVP)

## Overview

This specification defines the AppState structure and management patterns for RAG Studio's MVP implementation. The design uses a simplified Arc<RwLock<AppState>> shared state pattern with clear upgrade path to actor-based StateManager post-MVP.

## Architecture Decision

### MVP Approach: Simplified Shared State
- **Pattern**: Arc<RwLock<AppState>> for thread-safe shared access
- **Rationale**: Proven pattern, easy to implement, sufficient for MVP scale
- **Upgrade Path**: Clear migration to actor-based StateManager with mpsc channels post-MVP
- **Trade-offs**: Less scalable than actors but simpler to implement and debug

## AppState Structure

### Core State Fields
Based on CORE_DESIGN.md Table 1, the AppState contains 8-10 lean fields:

```rust
#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
pub struct AppState {
    /// Tools registry (FR-1)
    pub tools: HashMap<String, Tool>,

    /// Knowledge Base packs (FR-2)
    pub kb_packs: HashMap<String, KnowledgeBase>,

    /// Pipeline definitions and runs (FR-3)
    pub pipelines: HashMap<String, Pipeline>,
    pub pipeline_runs: HashMap<String, PipelineRun>,

    /// Scheduler configurations (FR-4)
    pub schedules: HashMap<String, Schedule>,

    /// Flow compositions (FR-6)
    pub flows: HashMap<String, Flow>,

    /// Application settings (FR-10)
    pub settings: AppSettings,

    /// Recent logs buffer (FR-8) - Ring buffer, cap ~100 entries
    pub recent_logs: VecDeque<LogEntry>,

    /// Performance metrics (FR-8) - HashMap with P50/P95 data
    pub metrics: HashMap<String, MetricValue>,

    /// Loading states (FR-11)
    pub loading_states: HashMap<String, bool>,

    /// Error states (FR-11)
    pub errors: HashMap<String, AppError>,
}
```

### State Component Definitions

```rust
#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
pub struct Tool {
    pub id: String,
    pub name: String,
    pub description: String,
    pub schema: serde_json::Value,
    pub endpoint_config: EndpointConfig,
    pub status: ToolStatus,
    pub created_at: DateTime<Utc>,
    pub updated_at: DateTime<Utc>,
}

#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
pub struct KnowledgeBase {
    pub id: String,
    pub name: String,
    pub version: String,
    pub description: Option<String>,
    pub status: KbStatus,
    pub health: KbHealth,
    pub metadata: KbMetadata,
    pub created_at: DateTime<Utc>,
    pub updated_at: DateTime<Utc>,
}

#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
pub struct Pipeline {
    pub id: String,
    pub name: String,
    pub description: Option<String>,
    pub steps: Vec<PipelineStep>,
    pub config: PipelineConfig,
    pub status: PipelineStatus,
    pub created_at: DateTime<Utc>,
    pub updated_at: DateTime<Utc>,
}

#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
pub struct PipelineRun {
    pub id: String,
    pub pipeline_id: String,
    pub status: RunStatus,
    pub started_at: DateTime<Utc>,
    pub completed_at: Option<DateTime<Utc>>,
    pub metrics: RunMetrics,
    pub error: Option<String>,
}

#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
pub struct Schedule {
    pub id: String,
    pub name: String,
    pub pipeline_id: String,
    pub cron_expression: String,
    pub enabled: bool,
    pub next_run: Option<DateTime<Utc>>,
    pub last_run: Option<DateTime<Utc>>,
    pub created_at: DateTime<Utc>,
}

#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
pub struct Flow {
    pub id: String,
    pub name: String,
    pub description: Option<String>,
    pub steps: Vec<FlowStep>,
    pub checksum: String,
    pub status: FlowStatus,
    pub created_at: DateTime<Utc>,
    pub updated_at: DateTime<Utc>,
}

#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
pub struct AppSettings {
    pub data_dir: PathBuf,
    pub air_gapped: bool,
    pub storage_quota_gb: u64,
    pub log_level: String,
    pub embedding_model: String,
    pub cache_ttl_seconds: u64,
}

#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
pub struct LogEntry {
    pub id: String,
    pub timestamp: DateTime<Utc>,
    pub level: LogLevel,
    pub component: String,
    pub message: String,
    pub metadata: Option<serde_json::Value>,
}

#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
pub struct MetricValue {
    pub name: String,
    pub value: f64,
    pub timestamp: DateTime<Utc>,
    pub labels: HashMap<String, String>,
}

#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
pub struct AppError {
    pub id: String,
    pub component: String,
    pub error_type: String,
    pub message: String,
    pub timestamp: DateTime<Utc>,
    pub recoverable: bool,
}
```

## State Management Implementation

### AppState Manager Service

```rust
use std::sync::{Arc, RwLock};
use std::collections::HashMap;
use tokio::sync::broadcast;

#[derive(Clone)]
pub struct AppStateManager {
    state: Arc<RwLock<AppState>>,
    event_sender: broadcast::Sender<StateEvent>,
}

impl AppStateManager {
    pub fn new() -> Self {
        let (event_sender, _) = broadcast::channel(1000);
        Self {
            state: Arc::new(RwLock::new(AppState::default())),
            event_sender,
        }
    }

    /// Read operations - acquire read lock
    pub fn read<T, F>(&self, f: F) -> Result<T, StateError>
    where
        F: FnOnce(&AppState) -> T,
    {
        let state = self.state.read()
            .map_err(|_| StateError::LockPoisoned)?;
        Ok(f(&*state))
    }

    /// Write operations - acquire write lock and emit events
    pub fn write<T, F>(&self, f: F) -> Result<T, StateError>
    where
        F: FnOnce(&mut AppState) -> (T, Option<StateEvent>),
    {
        let mut state = self.state.write()
            .map_err(|_| StateError::LockPoisoned)?;
        let (result, event) = f(&mut *state);

        if let Some(event) = event {
            // Fire and forget - don't block on receivers
            let _ = self.event_sender.send(event);
        }

        Ok(result)
    }

    /// Subscribe to state change events
    pub fn subscribe(&self) -> broadcast::Receiver<StateEvent> {
        self.event_sender.subscribe()
    }

    /// Get scoped state for specific operations
    pub fn get_kb_state(&self) -> Result<HashMap<String, KnowledgeBase>, StateError> {
        self.read(|state| state.kb_packs.clone())
    }

    pub fn get_pipeline_runs(&self) -> Result<HashMap<String, PipelineRun>, StateError> {
        self.read(|state| state.pipeline_runs.clone())
    }

    pub fn get_recent_logs(&self, limit: usize) -> Result<Vec<LogEntry>, StateError> {
        self.read(|state| {
            state.recent_logs
                .iter()
                .rev()
                .take(limit)
                .cloned()
                .collect()
        })
    }

    pub fn get_metrics(&self) -> Result<HashMap<String, MetricValue>, StateError> {
        self.read(|state| state.metrics.clone())
    }
}
```

### State Mutation Operations

```rust
impl AppStateManager {
    /// Add or update KB
    pub fn upsert_kb(&self, kb: KnowledgeBase) -> Result<(), StateError> {
        self.write(|state| {
            let event = if state.kb_packs.contains_key(&kb.id) {
                StateEvent::KbUpdated(kb.id.clone())
            } else {
                StateEvent::KbAdded(kb.id.clone())
            };

            state.kb_packs.insert(kb.id.clone(), kb);
            ((), Some(event))
        })
    }

    /// Add pipeline run
    pub fn add_pipeline_run(&self, run: PipelineRun) -> Result<(), StateError> {
        self.write(|state| {
            let event = StateEvent::RunAdded(run.id.clone());
            state.pipeline_runs.insert(run.id.clone(), run);
            ((), Some(event))
        })
    }

    /// Update pipeline run status
    pub fn update_run_status(&self, run_id: &str, status: RunStatus) -> Result<(), StateError> {
        self.write(|state| {
            if let Some(run) = state.pipeline_runs.get_mut(run_id) {
                run.status = status;
                if matches!(status, RunStatus::Completed | RunStatus::Failed) {
                    run.completed_at = Some(Utc::now());
                }
                let event = StateEvent::RunUpdated(run_id.to_string());
                ((), Some(event))
            } else {
                ((), None)
            }
        })
    }

    /// Add log entry with ring buffer management
    pub fn add_log_entry(&self, entry: LogEntry) -> Result<(), StateError> {
        self.write(|state| {
            // Maintain ring buffer size
            const MAX_LOG_ENTRIES: usize = 100;
            if state.recent_logs.len() >= MAX_LOG_ENTRIES {
                state.recent_logs.pop_front();
            }

            state.recent_logs.push_back(entry.clone());
            let event = StateEvent::LogAdded(entry.id);
            ((), Some(event))
        })
    }

    /// Update metric value
    pub fn update_metric(&self, name: String, value: f64, labels: HashMap<String, String>) -> Result<(), StateError> {
        self.write(|state| {
            let metric = MetricValue {
                name: name.clone(),
                value,
                timestamp: Utc::now(),
                labels,
            };

            state.metrics.insert(name.clone(), metric);
            let event = StateEvent::MetricUpdated(name);
            ((), Some(event))
        })
    }

    /// Set loading state
    pub fn set_loading(&self, component: String, loading: bool) -> Result<(), StateError> {
        self.write(|state| {
            if loading {
                state.loading_states.insert(component.clone(), true);
            } else {
                state.loading_states.remove(&component);
            }
            let event = StateEvent::LoadingChanged(component);
            ((), Some(event))
        })
    }

    /// Set error state
    pub fn set_error(&self, error: AppError) -> Result<(), StateError> {
        self.write(|state| {
            let component = error.component.clone();
            state.errors.insert(component.clone(), error);
            let event = StateEvent::ErrorOccurred(component);
            ((), Some(event))
        })
    }

    /// Clear error state
    pub fn clear_error(&self, component: &str) -> Result<(), StateError> {
        self.write(|state| {
            state.errors.remove(component);
            let event = StateEvent::ErrorCleared(component.to_string());
            ((), Some(event))
        })
    }
}
```

### State Events

```rust
#[derive(Debug, Clone, serde::Serialize)]
pub enum StateEvent {
    // KB Events
    KbAdded(String),
    KbUpdated(String),
    KbDeleted(String),

    // Pipeline Events
    PipelineAdded(String),
    PipelineUpdated(String),
    RunAdded(String),
    RunUpdated(String),

    // Tool Events
    ToolAdded(String),
    ToolUpdated(String),
    ToolDeleted(String),

    // Flow Events
    FlowAdded(String),
    FlowUpdated(String),

    // System Events
    LogAdded(String),
    MetricUpdated(String),
    LoadingChanged(String),
    ErrorOccurred(String),
    ErrorCleared(String),

    // Settings Events
    SettingsUpdated,
}

#[derive(Debug, thiserror::Error)]
pub enum StateError {
    #[error("State lock was poisoned")]
    LockPoisoned,

    #[error("Resource not found: {0}")]
    NotFound(String),

    #[error("Invalid state transition: {0}")]
    InvalidTransition(String),

    #[error("Serialization error: {0}")]
    SerializationError(#[from] serde_json::Error),
}
```

## Service Integration

### Manager DI Integration

```rust
// In Manager struct
pub struct Manager {
    pub state_manager: AppStateManager,
    pub sql_service: Arc<dyn SqlService>,
    pub vector_service: Arc<dyn VectorDbService>,
    pub storage_service: Arc<dyn StorageService>,
    // ... other services
}

impl Manager {
    pub fn new() -> Result<Self, ManagerError> {
        let state_manager = AppStateManager::new();

        // Initialize services with state manager access
        let sql_service = Arc::new(SqlServiceImpl::new(state_manager.clone())?);
        let vector_service = Arc::new(VectorDbServiceImpl::new()?);
        let storage_service = Arc::new(StorageServiceImpl::new()?);

        Ok(Self {
            state_manager,
            sql_service,
            vector_service,
            storage_service,
        })
    }

    /// Provide state manager to all modules that need it
    pub fn state_manager(&self) -> &AppStateManager {
        &self.state_manager
    }
}
```

### Module Integration Pattern

```rust
// Example KB Module integration
pub struct KbModule {
    state_manager: AppStateManager,
    sql_service: Arc<dyn SqlService>,
    vector_service: Arc<dyn VectorDbService>,
}

impl KbModule {
    pub fn new(
        state_manager: AppStateManager,
        sql_service: Arc<dyn SqlService>,
        vector_service: Arc<dyn VectorDbService>,
    ) -> Self {
        Self {
            state_manager,
            sql_service,
            vector_service,
        }
    }

    pub async fn hybrid_search(&self, query: SearchQuery) -> Result<SearchResults, KbError> {
        // Set loading state
        self.state_manager.set_loading("kb_search".to_string(), true)?;

        // Perform search operations...
        let results = self.perform_search(query).await?;

        // Update metrics
        self.state_manager.update_metric(
            "search_latency_ms".to_string(),
            results.latency_ms,
            HashMap::new(),
        )?;

        // Clear loading state
        self.state_manager.set_loading("kb_search".to_string(), false)?;

        Ok(results)
    }
}
```

## Memory Management

### Memory Constraints
- **Ring Buffer**: Recent logs capped at 100 entries
- **Metrics**: Keep last 1000 metric points per metric name
- **Total Memory Target**: <10MB for AppState in memory

### Cleanup Strategies
```rust
impl AppStateManager {
    /// Periodic cleanup of stale data
    pub fn cleanup_stale_data(&self) -> Result<(), StateError> {
        self.write(|state| {
            // Clean old logs (already handled by ring buffer)

            // Clean old metrics (keep last 1000 per metric)
            let cutoff = Utc::now() - chrono::Duration::hours(24);
            state.metrics.retain(|_, metric| metric.timestamp > cutoff);

            // Clean completed runs older than 7 days
            let run_cutoff = Utc::now() - chrono::Duration::days(7);
            state.pipeline_runs.retain(|_, run| {
                if let Some(completed_at) = run.completed_at {
                    completed_at > run_cutoff
                } else {
                    true // Keep running/pending runs
                }
            });

            // Clear resolved errors older than 1 hour
            let error_cutoff = Utc::now() - chrono::Duration::hours(1);
            state.errors.retain(|_, error| error.timestamp > error_cutoff);

            ((), Some(StateEvent::CleanupCompleted))
        })
    }
}
```

## Testing Strategy

### Unit Tests
```rust
#[cfg(test)]
mod tests {
    use super::*;

    #[tokio::test]
    async fn test_appstate_kb_operations() {
        let state_manager = AppStateManager::new();

        let kb = KnowledgeBase {
            id: "test_kb".to_string(),
            name: "Test KB".to_string(),
            version: "1.0".to_string(),
            status: KbStatus::Active,
            health: KbHealth::Healthy,
            // ... other fields
        };

        // Test add KB
        assert!(state_manager.upsert_kb(kb.clone()).is_ok());

        // Test read KB state
        let kb_state = state_manager.get_kb_state().unwrap();
        assert_eq!(kb_state.len(), 1);
        assert_eq!(kb_state.get("test_kb").unwrap().name, "Test KB");
    }

    #[tokio::test]
    async fn test_state_events() {
        let state_manager = AppStateManager::new();
        let mut event_receiver = state_manager.subscribe();

        // Add KB and verify event
        let kb = KnowledgeBase { /* ... */ };
        state_manager.upsert_kb(kb).unwrap();

        let event = event_receiver.recv().await.unwrap();
        match event {
            StateEvent::KbAdded(id) => assert_eq!(id, "test_kb"),
            _ => panic!("Expected KbAdded event"),
        }
    }

    #[tokio::test]
    async fn test_ring_buffer_cleanup() {
        let state_manager = AppStateManager::new();

        // Add 105 log entries
        for i in 0..105 {
            let entry = LogEntry {
                id: format!("log_{}", i),
                timestamp: Utc::now(),
                level: LogLevel::Info,
                component: "test".to_string(),
                message: format!("Test message {}", i),
                metadata: None,
            };
            state_manager.add_log_entry(entry).unwrap();
        }

        // Verify only 100 entries remain
        let logs = state_manager.get_recent_logs(200).unwrap();
        assert_eq!(logs.len(), 100);

        // Verify newest entries are kept
        assert_eq!(logs[0].id, "log_104");
        assert_eq!(logs[99].id, "log_5");
    }
}
```

## Error Handling

### Error Recovery Patterns
```rust
impl AppStateManager {
    /// Recover from corrupted state
    pub fn recover_from_error(&self, component: &str) -> Result<(), StateError> {
        match component {
            "kb" => self.reset_kb_state(),
            "pipelines" => self.reset_pipeline_state(),
            "metrics" => self.reset_metrics(),
            _ => Ok(()),
        }
    }

    fn reset_kb_state(&self) -> Result<(), StateError> {
        self.write(|state| {
            state.kb_packs.clear();
            state.loading_states.remove("kb");
            state.errors.retain(|k, _| !k.starts_with("kb_"));
            ((), Some(StateEvent::KbStateReset))
        })
    }
}
```

## Performance Considerations

### Read Performance
- Read operations use `RwLock::read()` for concurrent access
- Clone required data structures for return to avoid holding locks
- Use scoped read operations for specific data subsets

### Write Performance
- Write operations batch multiple changes when possible
- Event emission is fire-and-forget to avoid blocking
- Ring buffer and periodic cleanup prevent unbounded growth

### Memory Efficiency
- Use `VecDeque` for ring buffer with O(1) push/pop
- `HashMap` for O(1) lookups on keyed data
- Periodic cleanup prevents memory leaks

## Future Migration Path

### Actor System Upgrade
The current Arc<RwLock<AppState>> pattern provides a clear upgrade path to actor-based StateManager:

1. **Extract Domains**: Split AppState into domain-specific actors (KbActor, PipelineActor, etc.)
2. **mpsc Channels**: Replace RwLock with mpsc channels for each actor
3. **Message Passing**: Replace direct method calls with message passing
4. **Supervision**: Add actor supervision and restart policies

### Event Sourcing Integration
Current StateEvent system prepares for event sourcing:

1. **Event Store**: Persist StateEvents to events.db
2. **Replay**: Implement state reconstruction from event log
3. **Snapshots**: Periodic state snapshots for performance
4. **Undo/Redo**: Implement undo/redo from event history

## Implementation Priority

1. **Core AppState Structure** - Define data types and basic CRUD operations
2. **AppStateManager Service** - Implement thread-safe read/write operations
3. **Event System** - Add state change notifications
4. **Service Integration** - Integrate with Manager DI pattern
5. **Memory Management** - Implement cleanup and ring buffer logic
6. **Testing** - Comprehensive unit tests for all operations
7. **Error Recovery** - Graceful error handling and recovery patterns

## Success Criteria

- [ ] AppState supports all required data types (Tools, KBs, Pipelines, etc.)
- [ ] Thread-safe read/write operations with proper lock management
- [ ] Event notification system for state changes
- [ ] Memory usage under 10MB for typical workloads
- [ ] >95% test coverage for state operations
- [ ] Integration with Manager DI pattern
- [ ] Clear upgrade path to actor-based system documented