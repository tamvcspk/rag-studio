# 2.2.1 Tool Registry Specification

**Phase:** 2.2 MCP Server Implementation
**Component:** Tool Registry
**Priority:** HIGH
**Dependencies:** 2.1.1 KB Schema, 1.2.1 AppState, 1.3.4 Error Handling

## Overview

Implement the MCP Tool Registry for dynamic registration and management of `kb.*` tools via stdio MCP protocol, supporting tool validation, registration, capability declarations, and basic security isolation for MVP.

## Requirements

### Functional Requirements

#### FR-2.2.1.1 Core KB Tool Set
- Implement `kb.hybrid_search` - Vector/lexical search combination with adaptive reranking
- Implement `kb.get_document` - Document retrieval with optional range selection
- Implement `kb.stats` - Collection statistics and health metrics
- Implement `kb.list_collections` - KB enumeration with metadata and filtering
- Implement `kb.resolve_citations` - Citation resolution with license information
- Implement `kb.answer` - Full RAG answer generation with LLM integration

#### FR-2.2.1.2 Tool Discovery and Registration
- Support dynamic tool registration at runtime with hot-reload capability
- Implement tool discovery mechanism for available KB operations
- Provide tool metadata including descriptions, parameters, and examples
- Support tool versioning and capability declarations
- Enable graceful tool deprecation and migration paths

#### FR-2.2.1.3 Parameter Validation and Schema
- Implement JSON Schema validation for all tool inputs and outputs
- Support real-time parameter validation with descriptive error messages
- Provide auto-completion hints for tool parameters
- Validate required vs optional parameters with default values
- Support complex parameter types (objects, arrays, unions)

#### FR-2.2.1.4 Tool Execution and Lifecycle
- Execute tools with proper error handling and timeout management
- Support synchronous and asynchronous tool execution patterns
- Implement tool execution context with security boundaries
- Provide tool execution tracking and performance metrics
- Support tool cancellation and cleanup on interruption

#### FR-2.2.1.5 Security and Isolation
- Implement basic subprocess isolation for tool execution
- Support input sanitization and output validation
- Provide capability-based access control for tool operations
- Implement rate limiting and resource usage monitoring
- Support audit logging for security-relevant tool executions

### Non-Functional Requirements

#### NFR-2.2.1.1 Performance
- Tool registration must complete within 100ms per tool
- Tool execution latency must be under 10ms overhead (excluding actual operation)
- Support concurrent tool execution up to 50 parallel operations
- Memory usage for tool registry must stay under 10MB

#### NFR-2.2.1.2 Reliability
- Tool failures must not crash the MCP server process
- Support graceful degradation when tools are unavailable
- Implement automatic tool recovery and retry mechanisms
- Provide comprehensive error reporting and diagnostics

#### NFR-2.2.1.3 Maintainability
- Tool registration must be declarative and configuration-driven
- Support hot-reload of tool definitions during development
- Provide clear tool development and testing workflows
- Enable easy addition of new tools without server restart

## Technical Specification

### Tool Registry Architecture

```rust
use serde::{Deserialize, Serialize};
use std::collections::HashMap;
use std::sync::Arc;
use tokio::sync::RwLock;
use async_trait::async_trait;

#[derive(Debug, Clone)]
pub struct ToolRegistry {
    tools: Arc<RwLock<HashMap<String, Arc<dyn Tool>>>>,
    schemas: Arc<RwLock<HashMap<String, ToolSchema>>>,
    config: ToolRegistryConfig,
    metrics: Arc<RwLock<ToolMetrics>>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ToolRegistryConfig {
    pub max_concurrent_executions: usize,
    pub default_timeout_ms: u64,
    pub enable_audit_logging: bool,
    pub rate_limit_per_minute: usize,
    pub max_memory_usage_mb: usize,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ToolSchema {
    pub name: String,
    pub version: String,
    pub description: String,
    pub category: ToolCategory,
    pub input_schema: serde_json::Value,  // JSON Schema
    pub output_schema: serde_json::Value, // JSON Schema
    pub examples: Vec<ToolExample>,
    pub capabilities: Vec<String>,
    pub security_level: SecurityLevel,
    pub timeout_ms: Option<u64>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum ToolCategory {
    Search,
    Document,
    Collection,
    Admin,
    Analysis,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum SecurityLevel {
    ReadOnly,
    Write,
    Admin,
    System,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ToolExample {
    pub description: String,
    pub input: serde_json::Value,
    pub expected_output: serde_json::Value,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ToolExecutionContext {
    pub tool_name: String,
    pub execution_id: String,
    pub user_context: Option<String>,
    pub security_level: SecurityLevel,
    pub timeout_ms: u64,
    pub rate_limit_remaining: usize,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ToolExecutionResult {
    pub success: bool,
    pub output: Option<serde_json::Value>,
    pub error: Option<ToolError>,
    pub execution_time_ms: u64,
    pub metadata: HashMap<String, serde_json::Value>,
}

#[async_trait]
pub trait Tool: Send + Sync {
    fn schema(&self) -> &ToolSchema;

    async fn execute(
        &self,
        input: serde_json::Value,
        context: ToolExecutionContext,
    ) -> Result<serde_json::Value, ToolError>;

    async fn validate_input(&self, input: &serde_json::Value) -> Result<(), ToolError>;

    async fn health_check(&self) -> Result<ToolHealthStatus, ToolError>;
}

impl ToolRegistry {
    pub fn new(config: ToolRegistryConfig) -> Self {
        Self {
            tools: Arc::new(RwLock::new(HashMap::new())),
            schemas: Arc::new(RwLock::new(HashMap::new())),
            config,
            metrics: Arc::new(RwLock::new(ToolMetrics::default())),
        }
    }

    pub async fn register_tool(&self, tool: Arc<dyn Tool>) -> Result<(), ToolRegistryError> {
        let schema = tool.schema().clone();
        let name = schema.name.clone();

        // Validate tool schema
        self.validate_tool_schema(&schema).await?;

        // Register tool and schema
        {
            let mut tools = self.tools.write().await;
            let mut schemas = self.schemas.write().await;

            tools.insert(name.clone(), tool);
            schemas.insert(name.clone(), schema);
        }

        // Update metrics
        {
            let mut metrics = self.metrics.write().await;
            metrics.registered_tools += 1;
        }

        tracing::info!("Tool registered successfully: {}", name);
        Ok(())
    }

    pub async fn execute_tool(
        &self,
        tool_name: &str,
        input: serde_json::Value,
        context: ToolExecutionContext,
    ) -> Result<ToolExecutionResult, ToolRegistryError> {
        let start_time = std::time::Instant::now();

        // Get tool
        let tool = {
            let tools = self.tools.read().await;
            tools.get(tool_name)
                .ok_or_else(|| ToolRegistryError::ToolNotFound(tool_name.to_string()))?
                .clone()
        };

        // Validate input
        tool.validate_input(&input).await
            .map_err(ToolRegistryError::ValidationError)?;

        // Check rate limits
        self.check_rate_limits(&context).await?;

        // Execute with timeout
        let execution_future = tool.execute(input, context.clone());
        let result = tokio::time::timeout(
            std::time::Duration::from_millis(context.timeout_ms),
            execution_future,
        ).await;

        let execution_time = start_time.elapsed().as_millis() as u64;

        // Update metrics
        {
            let mut metrics = self.metrics.write().await;
            metrics.total_executions += 1;
            metrics.total_execution_time_ms += execution_time;
        }

        match result {
            Ok(Ok(output)) => {
                // Log successful execution
                if self.config.enable_audit_logging {
                    self.log_tool_execution(&context, true, execution_time, None).await;
                }

                Ok(ToolExecutionResult {
                    success: true,
                    output: Some(output),
                    error: None,
                    execution_time_ms: execution_time,
                    metadata: HashMap::new(),
                })
            }
            Ok(Err(error)) => {
                // Log failed execution
                if self.config.enable_audit_logging {
                    self.log_tool_execution(&context, false, execution_time, Some(&error)).await;
                }

                Ok(ToolExecutionResult {
                    success: false,
                    output: None,
                    error: Some(error),
                    execution_time_ms: execution_time,
                    metadata: HashMap::new(),
                })
            }
            Err(_) => {
                // Timeout
                let timeout_error = ToolError::Timeout {
                    tool_name: tool_name.to_string(),
                    timeout_ms: context.timeout_ms,
                };

                if self.config.enable_audit_logging {
                    self.log_tool_execution(&context, false, execution_time, Some(&timeout_error)).await;
                }

                Ok(ToolExecutionResult {
                    success: false,
                    output: None,
                    error: Some(timeout_error),
                    execution_time_ms: execution_time,
                    metadata: HashMap::new(),
                })
            }
        }
    }

    pub async fn list_tools(&self) -> Vec<ToolSchema> {
        let schemas = self.schemas.read().await;
        schemas.values().cloned().collect()
    }

    pub async fn get_tool_schema(&self, tool_name: &str) -> Option<ToolSchema> {
        let schemas = self.schemas.read().await;
        schemas.get(tool_name).cloned()
    }

    pub async fn health_check(&self) -> ToolRegistryHealth {
        let tools = self.tools.read().await;
        let mut healthy_tools = 0;
        let mut unhealthy_tools = 0;
        let mut tool_statuses = HashMap::new();

        for (name, tool) in tools.iter() {
            match tool.health_check().await {
                Ok(status) => {
                    healthy_tools += 1;
                    tool_statuses.insert(name.clone(), status);
                }
                Err(_) => {
                    unhealthy_tools += 1;
                    tool_statuses.insert(name.clone(), ToolHealthStatus::Unhealthy);
                }
            }
        }

        ToolRegistryHealth {
            total_tools: tools.len(),
            healthy_tools,
            unhealthy_tools,
            tool_statuses,
            registry_status: if unhealthy_tools == 0 {
                RegistryStatus::Healthy
            } else if healthy_tools > 0 {
                RegistryStatus::Degraded
            } else {
                RegistryStatus::Unhealthy
            },
        }
    }

    async fn validate_tool_schema(&self, schema: &ToolSchema) -> Result<(), ToolRegistryError> {
        // Validate JSON schemas
        use jsonschema::JSONSchema;

        // Validate input schema
        if let Err(e) = JSONSchema::compile(&schema.input_schema) {
            return Err(ToolRegistryError::InvalidSchema {
                tool_name: schema.name.clone(),
                schema_type: "input".to_string(),
                error: e.to_string(),
            });
        }

        // Validate output schema
        if let Err(e) = JSONSchema::compile(&schema.output_schema) {
            return Err(ToolRegistryError::InvalidSchema {
                tool_name: schema.name.clone(),
                schema_type: "output".to_string(),
                error: e.to_string(),
            });
        }

        // Validate examples
        let input_validator = JSONSchema::compile(&schema.input_schema).unwrap();
        let output_validator = JSONSchema::compile(&schema.output_schema).unwrap();

        for (i, example) in schema.examples.iter().enumerate() {
            if let Err(e) = input_validator.validate(&example.input) {
                return Err(ToolRegistryError::InvalidExample {
                    tool_name: schema.name.clone(),
                    example_index: i,
                    validation_errors: e.map(|err| err.to_string()).collect(),
                });
            }

            if let Err(e) = output_validator.validate(&example.expected_output) {
                return Err(ToolRegistryError::InvalidExample {
                    tool_name: schema.name.clone(),
                    example_index: i,
                    validation_errors: e.map(|err| err.to_string()).collect(),
                });
            }
        }

        Ok(())
    }

    async fn check_rate_limits(&self, context: &ToolExecutionContext) -> Result<(), ToolRegistryError> {
        if context.rate_limit_remaining == 0 {
            return Err(ToolRegistryError::RateLimitExceeded {
                tool_name: context.tool_name.clone(),
                limit: self.config.rate_limit_per_minute,
            });
        }
        Ok(())
    }

    async fn log_tool_execution(
        &self,
        context: &ToolExecutionContext,
        success: bool,
        execution_time_ms: u64,
        error: Option<&ToolError>,
    ) {
        let log_entry = ToolExecutionLog {
            timestamp: chrono::Utc::now(),
            execution_id: context.execution_id.clone(),
            tool_name: context.tool_name.clone(),
            user_context: context.user_context.clone(),
            success,
            execution_time_ms,
            error_message: error.map(|e| e.to_string()),
            security_level: context.security_level.clone(),
        };

        tracing::info!(
            "Tool execution: {} - {} - {}ms - {}",
            context.tool_name,
            if success { "SUCCESS" } else { "FAILED" },
            execution_time_ms,
            context.execution_id
        );

        // In production, this would be sent to audit log storage
        // For MVP, we log to structured logger
    }
}

// Supporting data structures
#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum ToolHealthStatus {
    Healthy,
    Degraded,
    Unhealthy,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum RegistryStatus {
    Healthy,
    Degraded,
    Unhealthy,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ToolRegistryHealth {
    pub total_tools: usize,
    pub healthy_tools: usize,
    pub unhealthy_tools: usize,
    pub tool_statuses: HashMap<String, ToolHealthStatus>,
    pub registry_status: RegistryStatus,
}

#[derive(Debug, Default, Clone, Serialize, Deserialize)]
pub struct ToolMetrics {
    pub registered_tools: usize,
    pub total_executions: u64,
    pub total_execution_time_ms: u64,
    pub failed_executions: u64,
    pub timeout_executions: u64,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ToolExecutionLog {
    pub timestamp: chrono::DateTime<chrono::Utc>,
    pub execution_id: String,
    pub tool_name: String,
    pub user_context: Option<String>,
    pub success: bool,
    pub execution_time_ms: u64,
    pub error_message: Option<String>,
    pub security_level: SecurityLevel,
}

#[derive(Debug, thiserror::Error)]
pub enum ToolError {
    #[error("Invalid input: {message}")]
    InvalidInput { message: String },

    #[error("Tool execution failed: {message}")]
    ExecutionFailed { message: String },

    #[error("Tool timeout after {timeout_ms}ms: {tool_name}")]
    Timeout { tool_name: String, timeout_ms: u64 },

    #[error("Resource unavailable: {resource}")]
    ResourceUnavailable { resource: String },

    #[error("Permission denied for operation: {operation}")]
    PermissionDenied { operation: String },

    #[error("Internal error: {message}")]
    Internal { message: String },
}

#[derive(Debug, thiserror::Error)]
pub enum ToolRegistryError {
    #[error("Tool not found: {0}")]
    ToolNotFound(String),

    #[error("Tool already registered: {0}")]
    ToolAlreadyRegistered(String),

    #[error("Invalid schema for tool {tool_name} ({schema_type}): {error}")]
    InvalidSchema {
        tool_name: String,
        schema_type: String,
        error: String,
    },

    #[error("Invalid example for tool {tool_name} (example {example_index}): {validation_errors:?}")]
    InvalidExample {
        tool_name: String,
        example_index: usize,
        validation_errors: Vec<String>,
    },

    #[error("Rate limit exceeded for tool {tool_name}: {limit} per minute")]
    RateLimitExceeded {
        tool_name: String,
        limit: usize,
    },

    #[error("Validation error: {0}")]
    ValidationError(ToolError),

    #[error("Registry capacity exceeded")]
    CapacityExceeded,
}
```

### KB Tool Implementations

```rust
// Implementation of core KB tools
use crate::services::{KbService, VectorDbService, SqlService};

pub struct KbHybridSearchTool {
    kb_service: Arc<dyn KbService>,
    schema: ToolSchema,
}

impl KbHybridSearchTool {
    pub fn new(kb_service: Arc<dyn KbService>) -> Self {
        let schema = ToolSchema {
            name: "kb.hybrid_search".to_string(),
            version: "1.0.0".to_string(),
            description: "Perform hybrid vector and lexical search across knowledge base collections".to_string(),
            category: ToolCategory::Search,
            input_schema: serde_json::json!({
                "type": "object",
                "properties": {
                    "query": {
                        "type": "string",
                        "description": "Search query text",
                        "minLength": 1,
                        "maxLength": 1000
                    },
                    "collection_ids": {
                        "type": "array",
                        "items": {"type": "string"},
                        "description": "List of collection IDs to search",
                        "minItems": 1,
                        "maxItems": 10
                    },
                    "top_k": {
                        "type": "integer",
                        "description": "Maximum number of results to return",
                        "minimum": 1,
                        "maximum": 100,
                        "default": 10
                    },
                    "filters": {
                        "type": "object",
                        "description": "Optional filters for search results",
                        "properties": {
                            "document_types": {"type": "array", "items": {"type": "string"}},
                            "date_range": {
                                "type": "object",
                                "properties": {
                                    "start": {"type": "string", "format": "date-time"},
                                    "end": {"type": "string", "format": "date-time"}
                                }
                            }
                        }
                    }
                },
                "required": ["query", "collection_ids"]
            }),
            output_schema: serde_json::json!({
                "type": "object",
                "properties": {
                    "results": {
                        "type": "array",
                        "items": {
                            "type": "object",
                            "properties": {
                                "chunk_id": {"type": "string"},
                                "document_id": {"type": "string"},
                                "collection_id": {"type": "string"},
                                "content": {"type": "string"},
                                "title": {"type": "string"},
                                "score": {"type": "number"},
                                "citation": {
                                    "type": "object",
                                    "properties": {
                                        "title": {"type": "string"},
                                        "source_url": {"type": ["string", "null"]},
                                        "license": {"type": ["string", "null"]},
                                        "version": {"type": ["string", "null"]}
                                    },
                                    "required": ["title"]
                                }
                            },
                            "required": ["chunk_id", "content", "score", "citation"]
                        }
                    },
                    "query_info": {
                        "type": "object",
                        "properties": {
                            "processed_query": {"type": "string"},
                            "total_results": {"type": "integer"}
                        }
                    },
                    "performance_metrics": {
                        "type": "object",
                        "properties": {
                            "total_time_ms": {"type": "integer"},
                            "vector_search_time_ms": {"type": "integer"},
                            "bm25_search_time_ms": {"type": "integer"}
                        }
                    }
                },
                "required": ["results"]
            }),
            examples: vec![
                ToolExample {
                    description: "Search for documents about machine learning".to_string(),
                    input: serde_json::json!({
                        "query": "machine learning algorithms",
                        "collection_ids": ["tech_docs"],
                        "top_k": 5
                    }),
                    expected_output: serde_json::json!({
                        "results": [
                            {
                                "chunk_id": "chunk_123",
                                "document_id": "doc_456",
                                "collection_id": "tech_docs",
                                "content": "Machine learning algorithms are computational methods...",
                                "title": "Introduction to Machine Learning",
                                "score": 0.85,
                                "citation": {
                                    "title": "ML Handbook",
                                    "source_url": "https://example.com/ml-handbook",
                                    "license": "CC-BY-4.0",
                                    "version": "v2.1"
                                }
                            }
                        ],
                        "query_info": {
                            "processed_query": "machine learning algorithms",
                            "total_results": 1
                        }
                    })
                }
            ],
            capabilities: vec!["hybrid_search".to_string(), "citations".to_string()],
            security_level: SecurityLevel::ReadOnly,
            timeout_ms: Some(5000),
        };

        Self { kb_service, schema }
    }
}

#[async_trait]
impl Tool for KbHybridSearchTool {
    fn schema(&self) -> &ToolSchema {
        &self.schema
    }

    async fn execute(
        &self,
        input: serde_json::Value,
        _context: ToolExecutionContext,
    ) -> Result<serde_json::Value, ToolError> {
        // Parse input
        let search_request: SearchRequest = serde_json::from_value(input)
            .map_err(|e| ToolError::InvalidInput {
                message: format!("Failed to parse search request: {}", e),
            })?;

        // Execute search
        let result = self.kb_service.hybrid_search(search_request).await
            .map_err(|e| ToolError::ExecutionFailed {
                message: format!("Search failed: {}", e),
            })?;

        // Convert to JSON
        serde_json::to_value(result)
            .map_err(|e| ToolError::Internal {
                message: format!("Failed to serialize result: {}", e),
            })
    }

    async fn validate_input(&self, input: &serde_json::Value) -> Result<(), ToolError> {
        use jsonschema::JSONSchema;

        let validator = JSONSchema::compile(&self.schema.input_schema)
            .map_err(|e| ToolError::Internal {
                message: format!("Schema compilation failed: {}", e),
            })?;

        if let Err(errors) = validator.validate(input) {
            let error_messages: Vec<String> = errors.map(|e| e.to_string()).collect();
            return Err(ToolError::InvalidInput {
                message: format!("Validation failed: {}", error_messages.join(", ")),
            });
        }

        Ok(())
    }

    async fn health_check(&self) -> Result<ToolHealthStatus, ToolError> {
        // Check if KB service is available
        match self.kb_service.health_check().await {
            Ok(_) => Ok(ToolHealthStatus::Healthy),
            Err(_) => Ok(ToolHealthStatus::Unhealthy),
        }
    }
}

// Similar implementations for other KB tools...
pub struct KbGetDocumentTool { /* ... */ }
pub struct KbStatsTool { /* ... */ }
pub struct KbListCollectionsTool { /* ... */ }
pub struct KbResolveCitationsTool { /* ... */ }
pub struct KbAnswerTool { /* ... */ }
```

## Implementation Details

### Tool Registration Strategy
- Use declarative tool registration with JSON schema validation
- Support hot-reload during development for rapid iteration
- Implement tool versioning with backward compatibility
- Provide comprehensive tool documentation and examples

### Security and Isolation
- Implement basic subprocess isolation for MVP
- Use capability-based access control for tool permissions
- Support input sanitization and output validation
- Provide audit logging for security-relevant operations

### Performance Optimization
- Minimize tool execution overhead (<10ms)
- Support concurrent tool execution with proper resource management
- Implement efficient tool lookup and caching
- Optimize JSON schema validation performance

## Testing Strategy

### Unit Tests
- Test individual tool implementations with various inputs
- Verify JSON schema validation accuracy
- Test error handling and edge cases
- Validate tool registration and discovery

### Integration Tests
- Test tool execution with real KB services
- Verify security and isolation boundaries
- Test concurrent tool execution under load
- Validate audit logging and metrics collection

### Performance Tests
- Benchmark tool registration and lookup times
- Test tool execution overhead and latency
- Measure memory usage under various loads
- Validate rate limiting and resource management

## Acceptance Criteria

### AC-2.2.1.1 Core Tool Set
- [ ] All six KB tools implemented and functional
- [ ] JSON Schema validation for inputs and outputs
- [ ] Comprehensive tool documentation and examples
- [ ] Tool health checks and monitoring

### AC-2.2.1.2 Registration System
- [ ] Dynamic tool registration with hot-reload
- [ ] Tool discovery and metadata management
- [ ] Version management and compatibility
- [ ] Graceful tool lifecycle management

### AC-2.2.1.3 Security and Performance
- [ ] Basic subprocess isolation implemented
- [ ] Input validation and output sanitization
- [ ] Tool execution under 10ms overhead
- [ ] Support for 50 concurrent tool executions

### AC-2.2.1.4 Error Handling and Monitoring
- [ ] Comprehensive error handling and reporting
- [ ] Audit logging for security events
- [ ] Performance metrics and monitoring
- [ ] Rate limiting and resource management