# 2.1.1 KB Schema Specification

**Phase:** 2.1 KB Data Model & API
**Component:** KB Schema
**Priority:** HIGH
**Dependencies:** 1.1.1 SQLite Setup, 1.1.2 LanceDB Integration

## Overview

Define the Knowledge Base (KB) schema for collections, documents, chunks, and metadata with versioning support, document fingerprinting for delta detection, and metadata enrichment pipeline.

## Requirements

### Functional Requirements

#### FR-2.1.1.1 KB Collection Schema
- Support versioned content repositories with atomic promotion
- Store collection metadata: name, description, version, created/updated timestamps
- Track embedding model version and configuration parameters
- Maintain collection-level statistics (document count, chunk count, size)
- Support collection-level access control and permissions

#### FR-2.1.1.2 Document Schema
- Store document metadata: title, source URL/path, content type, license
- Implement SHA-256 fingerprinting for delta detection and versioning
- Track document lifecycle: ingested, processed, indexed, failed states
- Support hierarchical document relationships (parent/child, references)
- Maintain document-level statistics and quality metrics

#### FR-2.1.1.3 Chunk Schema
- Store chunk content with position offsets within parent document
- Support configurable chunk sizes (256-1024 tokens) with overlap (10-50%)
- Maintain chunk-to-document relationships with citation anchors
- Store chunk-level metadata: language, encoding, extraction method
- Support semantic chunk boundaries (sentence, paragraph, section)

#### FR-2.1.1.4 Metadata Enrichment
- Extract and store structural metadata (headers, tables, lists, code blocks)
- Support custom metadata fields via JSON schema validation
- Implement automatic metadata inference (language detection, content type)
- Store extraction pipeline version and configuration
- Support metadata versioning and migration

#### FR-2.1.1.5 Versioning System
- Implement immutable document versions with copy-on-write semantics
- Support version branching and merging for collaborative editing
- Maintain version history with delta compression
- Enable atomic rollback to previous versions
- Track version genealogy and dependency chains

### Non-Functional Requirements

#### NFR-2.1.1.1 Performance
- Index operations must complete within 5 seconds for documents <10MB
- Schema queries must execute within 100ms for collections <100K documents
- Memory usage must not exceed 50MB for schema operations
- Support concurrent access with minimal lock contention

#### NFR-2.1.1.2 Scalability
- Support collections up to 1M documents and 10M chunks
- Handle document sizes up to 100MB with streaming processing
- Scale to 100 concurrent schema operations
- Efficient storage with <20% overhead for metadata

#### NFR-2.1.1.3 Reliability
- Ensure ACID compliance for all schema operations
- Implement automatic schema migration and rollback
- Validate schema integrity on startup and after operations
- Support crash recovery with transaction log replay

## Technical Specification

### Database Schema (SQLite)

```sql
-- Collections table
CREATE TABLE collections (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    name TEXT NOT NULL UNIQUE,
    description TEXT,
    version INTEGER NOT NULL DEFAULT 1,
    embedding_model TEXT NOT NULL,
    embedding_config JSON,
    chunk_size INTEGER NOT NULL DEFAULT 512,
    chunk_overlap INTEGER NOT NULL DEFAULT 50,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    status TEXT CHECK (status IN ('active', 'building', 'failed', 'archived')) DEFAULT 'building',
    document_count INTEGER DEFAULT 0,
    chunk_count INTEGER DEFAULT 0,
    total_size INTEGER DEFAULT 0,
    health_score REAL DEFAULT 1.0,
    metadata JSON
);

-- Documents table
CREATE TABLE documents (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    collection_id INTEGER NOT NULL,
    title TEXT NOT NULL,
    source_path TEXT,
    source_url TEXT,
    content_type TEXT NOT NULL,
    license TEXT,
    language TEXT,
    encoding TEXT DEFAULT 'utf-8',
    fingerprint TEXT NOT NULL, -- SHA-256 hash
    size INTEGER NOT NULL,
    chunk_count INTEGER DEFAULT 0,
    status TEXT CHECK (status IN ('pending', 'processing', 'indexed', 'failed')) DEFAULT 'pending',
    version INTEGER NOT NULL DEFAULT 1,
    parent_id INTEGER REFERENCES documents(id),
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    indexed_at TIMESTAMP,
    metadata JSON,
    error_message TEXT,
    FOREIGN KEY (collection_id) REFERENCES collections(id) ON DELETE CASCADE,
    UNIQUE(collection_id, fingerprint, version)
);

-- Chunks table
CREATE TABLE chunks (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    document_id INTEGER NOT NULL,
    collection_id INTEGER NOT NULL,
    content TEXT NOT NULL,
    position INTEGER NOT NULL, -- Position within document
    start_offset INTEGER NOT NULL, -- Character offset in source
    end_offset INTEGER NOT NULL,
    token_count INTEGER NOT NULL,
    chunk_type TEXT CHECK (chunk_type IN ('text', 'code', 'table', 'header', 'list')) DEFAULT 'text',
    embedding_id TEXT, -- Reference to LanceDB vector
    citation_anchor TEXT, -- For reference generation
    language TEXT,
    metadata JSON,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (document_id) REFERENCES documents(id) ON DELETE CASCADE,
    FOREIGN KEY (collection_id) REFERENCES collections(id) ON DELETE CASCADE
);

-- Document versions table
CREATE TABLE document_versions (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    document_id INTEGER NOT NULL,
    version INTEGER NOT NULL,
    fingerprint TEXT NOT NULL,
    delta_from_version INTEGER,
    delta_data BLOB, -- Compressed delta
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (document_id) REFERENCES documents(id) ON DELETE CASCADE,
    UNIQUE(document_id, version)
);

-- Metadata schemas table
CREATE TABLE metadata_schemas (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    name TEXT NOT NULL UNIQUE,
    version INTEGER NOT NULL,
    schema JSON NOT NULL, -- JSON Schema definition
    description TEXT,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    UNIQUE(name, version)
);

-- Indexes for performance
CREATE INDEX idx_documents_collection_id ON documents(collection_id);
CREATE INDEX idx_documents_fingerprint ON documents(fingerprint);
CREATE INDEX idx_documents_status ON documents(status);
CREATE INDEX idx_chunks_document_id ON chunks(document_id);
CREATE INDEX idx_chunks_collection_id ON chunks(collection_id);
CREATE INDEX idx_chunks_position ON chunks(position);
CREATE INDEX idx_chunks_embedding_id ON chunks(embedding_id);
CREATE INDEX idx_document_versions_document_id ON document_versions(document_id);
```

### Rust Data Structures

```rust
use serde::{Deserialize, Serialize};
use chrono::{DateTime, Utc};
use std::collections::HashMap;

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Collection {
    pub id: Option<i64>,
    pub name: String,
    pub description: Option<String>,
    pub version: i32,
    pub embedding_model: String,
    pub embedding_config: serde_json::Value,
    pub chunk_size: i32,
    pub chunk_overlap: i32,
    pub created_at: DateTime<Utc>,
    pub updated_at: DateTime<Utc>,
    pub status: CollectionStatus,
    pub document_count: i64,
    pub chunk_count: i64,
    pub total_size: i64,
    pub health_score: f64,
    pub metadata: Option<serde_json::Value>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum CollectionStatus {
    Active,
    Building,
    Failed,
    Archived,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Document {
    pub id: Option<i64>,
    pub collection_id: i64,
    pub title: String,
    pub source_path: Option<String>,
    pub source_url: Option<String>,
    pub content_type: String,
    pub license: Option<String>,
    pub language: Option<String>,
    pub encoding: String,
    pub fingerprint: String, // SHA-256
    pub size: i64,
    pub chunk_count: i64,
    pub status: DocumentStatus,
    pub version: i32,
    pub parent_id: Option<i64>,
    pub created_at: DateTime<Utc>,
    pub updated_at: DateTime<Utc>,
    pub indexed_at: Option<DateTime<Utc>>,
    pub metadata: Option<serde_json::Value>,
    pub error_message: Option<String>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum DocumentStatus {
    Pending,
    Processing,
    Indexed,
    Failed,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Chunk {
    pub id: Option<i64>,
    pub document_id: i64,
    pub collection_id: i64,
    pub content: String,
    pub position: i32,
    pub start_offset: i32,
    pub end_offset: i32,
    pub token_count: i32,
    pub chunk_type: ChunkType,
    pub embedding_id: Option<String>,
    pub citation_anchor: Option<String>,
    pub language: Option<String>,
    pub metadata: Option<serde_json::Value>,
    pub created_at: DateTime<Utc>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum ChunkType {
    Text,
    Code,
    Table,
    Header,
    List,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct DocumentVersion {
    pub id: Option<i64>,
    pub document_id: i64,
    pub version: i32,
    pub fingerprint: String,
    pub delta_from_version: Option<i32>,
    pub delta_data: Option<Vec<u8>>,
    pub created_at: DateTime<Utc>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct MetadataSchema {
    pub id: Option<i64>,
    pub name: String,
    pub version: i32,
    pub schema: serde_json::Value, // JSON Schema
    pub description: Option<String>,
    pub created_at: DateTime<Utc>,
}
```

## Implementation Details

### Fingerprinting Strategy
- Use SHA-256 for document content fingerprinting
- Include metadata in fingerprint calculation for full delta detection
- Support incremental fingerprinting for large documents
- Store fingerprints in base64 encoding for efficiency

### Metadata Enrichment Pipeline
- Implement pluggable metadata extractors
- Support automatic language detection using whatlang-rs
- Extract structural elements using markup parsers
- Validate custom metadata against JSON schemas
- Store extraction pipeline version for reproducibility

### Version Management
- Implement copy-on-write semantics for document versions
- Use binary delta compression for efficient storage
- Support atomic version promotion with rollback capability
- Maintain version genealogy for dependency tracking

## Testing Strategy

### Unit Tests
- Test schema validation and constraint enforcement
- Verify fingerprinting accuracy and collision resistance
- Test metadata extraction and validation
- Validate version management operations

### Integration Tests
- Test schema operations with SQLite and LanceDB
- Verify concurrent access patterns
- Test migration scenarios and rollback procedures
- Validate performance with large datasets

### Performance Tests
- Benchmark schema operations with varying data sizes
- Test concurrent access under load
- Measure memory usage patterns
- Validate query performance with realistic data

## Migration Strategy

### Schema Versioning
- Implement diesel migrations for schema evolution
- Support backward compatibility for at least 2 versions
- Provide migration scripts for data transformation
- Test migration procedures in development environment

### Data Migration
- Support incremental migration for large datasets
- Implement rollback procedures for failed migrations
- Validate data integrity after migration
- Provide progress reporting for long-running migrations

## Acceptance Criteria

### AC-2.1.1.1 Schema Definition Complete
- [ ] All tables created with proper constraints and indexes
- [ ] Rust data structures match SQL schema exactly
- [ ] Foreign key relationships properly defined
- [ ] Schema validation passes all tests

### AC-2.1.1.2 Fingerprinting System
- [ ] SHA-256 fingerprinting implemented and tested
- [ ] Delta detection works for document changes
- [ ] Collision resistance verified with test data
- [ ] Performance meets requirements (<1s for 10MB documents)

### AC-2.1.1.3 Metadata Enrichment
- [ ] Pluggable metadata extractor architecture
- [ ] Language detection accuracy >95% for supported languages
- [ ] Custom metadata validation via JSON Schema
- [ ] Pipeline versioning and reproducibility

### AC-2.1.1.4 Version Management
- [ ] Immutable versioning with copy-on-write
- [ ] Atomic rollback capability
- [ ] Version genealogy tracking
- [ ] Delta compression efficiency >70%

### AC-2.1.1.5 Performance Requirements
- [ ] Schema operations complete within specified timeframes
- [ ] Memory usage stays within limits
- [ ] Concurrent access performance validated
- [ ] Query performance meets targets